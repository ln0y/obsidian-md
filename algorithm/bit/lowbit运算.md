---
aliases: []
tags: ['algorithm/bit', 'date/2023-11', 'year/2023', 'month/11']
date: 2023-11-25-星期六 16:40:28
update: 2023-11-25-星期六 16:44:39
---

## lowbit 的概念

我们知道，任何一个正整数都可以被表示成一个二进制数。如：

$$
(2)_{10}=(10)_2
$$

$$
(4)_{10}=(100)_2
$$

$$
\cdots
$$

那么定义一个函数 $f=lowbit(x)$，这个函数的值是 $x$ 的二进制表达式中最低位的 $1$ 所对应的值。

比如:

$$
(6)_{10}=(110)_2
$$

那么 $lowbit(6)$ 就等于 $2$，因为 $(110)_2$ 中最低位（就是从右往左数的第二位）对应的数是 $2^1=2$

所以假设一个数的二进制最低位的 $1$ 在从右往左数的第 $k$ 位，那么它的 $lowbit$ 值就是

$$
2^{k-1}
$$

## lowbit 函数的实现

lowbit 函数实现有两种方式：

- `x&(x^(x-1))`
- `x&-x`

简单解释一下：

我们得到 lowbit 的值，只需要得到最后一个 1 的位置，并且把除了这个位置之外的所有位置全部置成零。然后输出就可以。

### `x&(x^(x-1))`

拿上面的 6 举例：

$$
(110)_2-1=(101)_2
$$

我们发现，根据小学数学减法运算的借位原则，对一个二进制数进行减 1，那么会出现从这个这个数的最后一个 1 开始到最后的所有数都取反，即构成一个 $01111\cdots$ 的串。

我们把这个数与原数异或，就会造成：第一个 1 以后的数（包括第一个 1）全部取 1.其他的位全部取 0.即构成一个由一堆 0 后面跟一堆 1 的串。

那么再把原式做一个与运算，那么除了原来的那个 1（对应位都是 1）为 1，其他位全是 0，完成任务。

### `x&-x`

根据计算机补码的性质。

补码就是原码的反码加一

如：

$$
(110)_2=6
$$

反码：

$$
(001)_2
$$

加一：

$$
(010)_2
$$

可以发现变为反码后 x 与反码数字位每一位都不同， 所以当反码加 1 后神奇的事情发生了，反码会逢 1 一直进位直到遇到 0，且这个 0 变成了 1，所以这个数最后面构造了一个 100… 串。 由于是反码，进位之后由于 1 的作用使进位的部分全部取反及与原码相同，所以可以发现 lowbit 以前的部分 x 与其补码即 -x 相反， lowbit x 与 -x 都是 1，lowbit 以后 x 与 -x 都是 0 所以 x&-x 后除了 lowbit 位是 1，其余位都是 0。符合条件。

## 用 lowbit 运算统计 1 的个数

我们可以使用 lowbit 运算统计一个整数的二进制形式下 1 的个数。

实现原理很简单啦，就是：我们先用 lowbit 运算找出 $lowbit(x)$，然后用原数减去这个数，依次循环，直到为 0 为止。

这也是树状数组的实现原理。

代码：

```js
while (x) {
  x -= x & -x
  ans++
}
```

## lowbit 运算的应用

关于 lowbit 运算，最著名的应用应该算是树状数组。但是 lowbit 的神妙远远不止树状数组，在很多二进制和位运算的相关题目中，都有 lowbit 运算的影子。甚至，在状态压缩 DP 中，lowbit 也扮演着一份不可忽视的角色。
