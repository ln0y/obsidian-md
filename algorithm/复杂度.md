---
aliases: []
tags: ['algorithm','date/2022-04','year/2022','month/04']
date: 2022-04-18-Monday 16:02:24
update: 2022-04-18-Monday 17:48:46
---

## 复杂度是什么

**复杂度是衡量代码运行效率的重要度量因素**。在介绍复杂度之前，有必要先看一下复杂度和计算机实际任务处理效率的关系，从而了解降低复杂度的必要性。

计算机通过一个个程序去执行计算任务，也就是对输入数据进行加工处理，并最终得到结果的过程。每个程序都是由代码构成的。可见，编写代码的核心就是要完成计算。但对于同一个计算任务，不同计算方法得到结果的过程复杂程度是不一样的，这对你实际的任务处理效率就有了非常大的影响。

举个例子，你要在一个在线系统中实时处理数据。假设这个系统平均每分钟会新增 300M 的数据量。如果你的代码不能在 1 分钟内完成对这 300M 数据的处理，那么这个系统就会发生时间爆炸和空间爆炸。表现就是，电脑执行越来越慢，直到死机。因此，我们需要讲究合理的计算方法，去通过尽可能低复杂程度的代码完成计算任务。

那提到降低复杂度，我们首先需要知道怎么衡量复杂度。而在实际衡量时，我们通常会围绕以下2 个维度进行。**首先，这段代码消耗的资源是什么**。一般而言，代码执行过程中会消耗计算时间和计算空间，那需要衡量的就是`时间复杂度`和`空间复杂度`。

举一个实际生活中的例子。某个十字路口没有建立立交桥时，所有车辆通过红绿灯分批次行驶通过。当大量汽车同时过路口的时候，就会分别消耗大家的时间。但建了立交桥之后，所有车辆都可以同时通过了，因为立交桥的存在，等于是消耗了空间资源，来换取了时间资源。

**其次，这段代码对于资源的消耗是多少**。我们不会关注这段代码对于资源消耗的绝对量，因为不管是时间还是空间，它们的消耗程度都与输入的数据量高度相关，输入数据少时消耗自然就少。为了更客观地衡量消耗程度，我们通常会关注时间或者空间消耗量与输入数据量之间的关系。

好，现在我们已经了解了衡量复杂度的两个纬度，那应该如何去计算复杂度呢？

**复杂度是一个关于输入数据量 n 的函数**。假设你的代码复杂度是 $f(n)$，那么就用个大写字母 O 和括号，把 $f(n)$ 括起来就可以了，即 $O(f(n))$。例如，$O(n)$ 表示的是，复杂度与计算实例的个数 n 线性相关；$O(log n)$ 表示的是，复杂度与计算实例的个数 n 对数相关。

通常，复杂度的计算方法遵循以下几个原则：

- 首先，**复杂度与具体的常系数无关**，例如 $O(n)$ 和 $O(2n)$ 表示的是同样的复杂度。我们详细分析下，$O(2n)$ 等于 $O(n+n)$，也等于 $O(n) + O(n)$。也就是说，一段 $O(n)$ 复杂度的代码只是先后执行两遍 $O(n)$，其复杂度是一致的。
- 其次，**多项式级的复杂度相加的时候，选择高者作为结果**，例如 $O(n^2)+O(n)$ 和 $O(n^2)$ 表示的是同样的复杂度。具体分析一下就是，$O(n^2)+O(n) = O(n^2+n)$。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。

值得一提的是，**$O(1)$ 也是表示一个特殊复杂度**，含义为某个任务通过有限可数的资源即可完成。此处有限可数的具体意义是，**与输入数据量 n 无关**。

例如，你的代码处理 10 条数据需要消耗 5 个单位的时间资源，3 个单位的空间资源。处理 1000 条数据，还是只需要消耗 5 个单位的时间资源，3 个单位的空间资源。那么就能发现资源消耗与输入数据量无关，就是 $O(1)$ 的复杂度。

为了方便你理解不同计算方法对复杂度的影响，我们来看一个代码任务：对于输入的数组，输出与之逆序的数组。例如，输入 a=\[1,2,3,4,5\]，输出 \[5,4,3,2,1\]。

先看**方法一**，建立并初始化数组 b，得到一个与输入数组等长的全零数组。通过一个 for 循环，从左到右将 a 数组的元素，从右到左地赋值到 b 数组中，最后输出数组 b 得到结果。

![[Ciqc1F7CRP6ARwDTAGHL-opG6Bk835.gif]]

代码如下：

```js
function s1_1 () {
  const a = [1, 2, 3, 4, 5]
  const b = []
  for (let i = 0; i < a.length; i++) {
    b[i] = a[i]
  }
  for (let i = 0; i < a.length; i++) {
    b[a.length - i - 1] = a[i]
  }
  console.log(b)
}
```

这段代码的输入数据是 a，数据量就等于数组 a 的长度。代码中有两个 for 循环，作用分别是给b 数组初始化和赋值，其执行次数都与输入数据量相等。因此，代码的**时间复杂度**就是 $O(n)+O(n)$，也就是 $O(n)$。

空间方面主要体现在计算过程中，对于存储资源的消耗情况。上面这段代码中，我们定义了一个新的数组 b，它与输入数组 a 的长度相等。因此，空间复杂度就是 $O(n)$。

**接着我们看一下第二种编码方法**，它定义了缓存变量 tmp，接着通过一个 for 循环，从 0 遍历到a 数组长度的一半（即 $len(a)/2$）。每次遍历执行的是什么内容？就是交换首尾对应的元素。最后打印数组 a，得到结果。

![[Ciqc1F7CR22AIbSuABc0Rwl-t3w666.gif]]

代码如下：

```js
function s1_2 () {
  const a = [1, 2, 3, 4, 5]
  let tmp = 0
  for (let i = 0; i < (a.length / 2); i++) {
    tmp = a[i]
    a[i] = a[a.length - i - 1]
    a[a.length - i - 1] = tmp;
  }
  console.log(a)
}
```

这段代码包含了一个 for 循环，执行的次数是数组长度的一半，时间复杂度变成了 $O(n/2)$。根据复杂度与具体的常系数无关的性质，这段代码的时间复杂度也就是 $O(n)$。

空间方面，我们定义了一个 tmp 变量，它与数组长度无关。也就是说，输入是 5 个元素的数组，需要一个 tmp 变量；输入是 50 个元素的数组，依然只需要一个 tmp 变量。因此，空间复杂度与输入数组长度无关，即 $O(1)$。

可见，**对于同一个问题，采用不同的编码方法，对时间和空间的消耗是有可能不一样的**。因此，工程师在写代码的时候，一方面要完成任务目标；另一方面，也需要考虑时间复杂度和空间复杂度，以求用尽可能少的时间损耗和尽可能少的空间损耗去完成任务。

## 时间复杂度与代码结构的关系

从本质来看，时间复杂度与代码的结构有着非常紧密的关系；而空间复杂度与数据结构的设计有关。接下来我先来系统地讲一下时间复杂度和代码结构的关系。

代码的**时间复杂度，与代码的结构有非常强的关系**，我们一起来看一些具体的例子。

例 1，定义了一个数组 a = \[1, 4, 3\]，查找数组 a 中的最大值，代码如下：

```js
function s1_3 () {
  const a = [1, 4, 3]
  let maxVal = -1
  for (let i = 0; i < a.length; i++) {
    if (a[i] > maxVal) {
      maxVal = a[i]
    }
  }
  console.log(maxVal)
}
```

这个例子比较简单，实现方法就是，暂存当前最大值并把所有元素遍历一遍即可。因为代码的结构上需要使用一个 for 循环，对数组所有元素处理一遍，所以时间复杂度为 $O(n)$。

例2，下面的代码定义了一个数组 a = \[1, 3, 4, 3, 4, 1, 3\]，并会在这个数组中查找出现次数最多的那个数字：

```js
function s1_4 () {
  const a = [1, 3, 4, 3, 4, 1, 3]
  let maxVal = -1
  let maxTime = 0
  let tmpTime = 0
  for (let i = 0; i < a.length; i++) {
    tmpTime = 0
    for (let j = i; j < a.length; j++) {
      if (a[j] === a[i]) {
        tmpTime++
      }
    }
    if (tmpTime > maxTime) {
      maxTime = tmpTime
      maxVal = a[i]
    }
  }
  console.log(maxVal)
}
```

这段代码中，我们采用了双层循环的方式计算：第一层循环，我们对数组中的每个元素进行遍历；第二层循环，对于每个元素计算出现的次数，并且通过当前元素次数 tmpTime 和全局最大次数变量 maxTime 的大小关系，持续保存出现次数最多的那个元素及其出现次数。由于是双层循环，这段代码在时间方面的消耗就是 $n*n$ 的复杂度，也就是 $O(n²)$。

在这里，我们给出一些经验性的结论：

- 一个顺序结构的代码，时间复杂度是 $O(1)$。
- 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 $O(logn)$。
- 一个简单的 for 循环，时间复杂度是 $O(n)$。
- 两个顺序执行的 for 循环，时间复杂度是 $O(n)+O(n)=O(2n)$，其实也是 $O(n)$。
- 两个嵌套的 for 循环，时间复杂度是 $O(n^2)$。

有了这些基本的结论，再去分析代码的时间复杂度将会轻而易举。

## 降低时间复杂度的必要性

很多新手的工程师，对降低时间复杂度并没有那么强的意识。这主要是在学校或者实验室中，参加的课程作业或者科研项目，普遍都不是实时的、在线的工程环境。

实际的在线环境中，用户的访问请求可以看作一个流式数据。假设这个数据流中，每个访问的平均时间间隔是 t。如果你的代码无法在 t 时间内处理完单次的访问请求，那么这个系统就会一波未平一波又起，最终被大量积压的任务给压垮。这就要求工程师必须通过优化代码、优化数据结构，来降低时间复杂度。

为了更好理解，我们来看一些数据。假设某个计算任务需要处理 10 万 条数据。你编写的代码：

- 如果是 $O(n^2)$ 的时间复杂度，那么计算的次数就大概是 100 亿次左右。
- 如果是 $O(n)$，那么计算的次数就是 10 万 次左右。
- 如果这个工程师再厉害一些，能在 $O(log n)$ 的复杂度下完成任务，那么计算的次数就是 17 次左右（log 100000 = 16.61，计算机通常是二分法，这里的对数`可以以 2 为底`去估计）。

### 时间昂贵、空间廉价

一段代码会消耗计算时间、资源空间，从而产生时间复杂度和空间复杂度，那么你是否尝试过将时间复杂度和空间复杂进行下对比呢？其实对比过后，你就会发现一个重要的现象。

**假设一段代码经过优化后，虽然降低了时间复杂度，但依然需要消耗非常高的空间复杂度。** 例如，对于固定数据量的输入，这段代码需要消耗几十 G 的内存空间，很显然普通计算机根本无法完成这样的计算。如果一定要解决的话，一个最简单粗暴的办法就是，购买大量的高性能计算机，来弥补空间性能的不足。

**反过来，假设一段代码经过优化后，依然需要消耗非常高的时间复杂度。** 例如，对于固定数据量的输入，这段代码需要消耗 1 年的时间去完成计算。如果在跑程序的 1 年时间内，出现了断电、断网或者程序抛出异常等预期范围之外的问题，那很可能造成 1 年时间浪费的惨重后果。很显然，用 1 年的时间去跑一段代码，对开发者和运维者而言都是极不友好的。

这告诉我们一个什么样的现实问题呢？代码效率的瓶颈可能发生在时间或者空间两个方面。如果是缺少计算空间，花钱买服务器就可以了。这是个花钱就能解决的问题。相反，如果是缺少计算时间，只能投入宝贵的人生去跑程序。即使你有再多的钱、再多的服务器，也是毫无用处。相比于空间复杂度，时间复杂度的降低就显得更加重要了。因此，你会发现这样的结论：空间是廉价的，而时间是昂贵的。

### 数据结构连接时空

假定在不限制时间、也不限制空间的情况下，你可以完成某个任务的代码的开发。这就是通常我们所说的**暴力解法**，更是程序优化的起点。

例如，如果要在 100 以内的正整数中，找到同时满足以下两个条件的最小数字：

1. 能被 3 整除；
2. 除 5 余 2。

最暴力的解法就是，从 1 开始到 100，每个数字都做一次判断。如果这个数字满足了上述两个条件，则返回结果。这是一种不计较任何时间复杂度或空间复杂度的、最直观的暴力解法。

当你有了最暴力的解法后，就需要评估当前暴力解法的复杂度了。如果复杂度比较低或者可以接受，那自然万事大吉。可如果暴力解法复杂度比较高的话，那就要考虑采用**程序优化**的方法去降低复杂度了。

为了降低复杂度，一个直观的思路是：梳理程序，看其流程中是否有无效的计算或者无效的存储。

我们需要从时间复杂度和空间复杂度两个维度来考虑。常用的**降低时间复杂度**的方法有**递归、二分法、排序算法、动态规划**等。而降低空间复杂度的方法，就要围绕**数据结构**做文章了。

**降低空间复杂度的核心思路就是，_能用低复杂度的数据结构能解决问题，就千万不要用高复杂度的数据结构。_**

经过了前面剔除无效计算和存储的处理之后，如果程序在时间和空间等方面的性能依然还有瓶颈，又该怎么办呢？前面我们提到过，空间是廉价的，最不济也是可以通过购买更高性能的计算机进行解决的。然而时间是昂贵的，如果无法降低时间复杂度，那系统的效率就永远无法得到提高。

这时候，开发者们想到这样的一个解决思路。如果可以通过某种方式，把时间复杂度转移到空间复杂度的话，就可以把无价的东西变成有价了。这种时空转移的思想，在实际生活中也会经常遇到。

例如，马路上的十字路口，所有车辆在通过红绿灯时需要分批次通行。这样，就消耗了所有车辆的通行时间。如果要降低这里的时间损耗，人们就想到了修建立交桥。修建立交桥后，每个可能的转弯或直行的行进路线，都有专属的一条公路支持。这样，车辆就不需要全部去等待红绿灯分批通行了。最终，实现了用空间换取时间。

其实，程序开发也是可以借鉴这里的思想的。在程序开发中，连接时间和空间的桥梁就是**数据结构**。对于一个开发任务，如果你能找到一种高效的数据组织方式，采用合理的数据结构的话，那就可以实现时间复杂度的再次降低。同样的，这通常会增加数据的存储量，也就是增加了空间复杂度。

以上就是程序优化的最核心的思路。我们简单梳理如下：

- 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。
- 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
- 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

### 降低复杂度的案例

第 1 个例子，假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性。假设工程师小明写了下面的代码：

```js
function s1_5 () {
  let count = 0
  for (let i = 0; i <= (100 / 7); i++) {
    for (let j = 0; j <= (100 / 3); j++) {
      for (let k = 0; k <= (100 / 2); k++) {
        if (i * 7 + j * 3 + k * 2 == 100) {
          count += 1
        }
      }
    }
  }
  console.log(count)
}
```

在这段代码中，使用了 3 层的 for 循环。从结构上来看，是很显然的 $O(n^3)$ 的时间复杂度。然而，仔细观察就会发现，代码中最内层的 for 循环是多余的。因为，当你确定了要用 i 张 7 元和 j 张 3 元时，只需要判断用有限个 2 元能否凑出 $100 - 7 * i - 3 * j$ 元就可以了。因此，代码改写如下：

```js
function s1_6 () {
  let count = 0
  for (let i = 0; i <= (100 / 7); i++) {
    for (let j = 0; j <= (100 / 3); j++) {
      if ((100 - i * 7 - j * 3 >= 0) && ((100 - i * 7 - j * 3) % 2 == 0)) {
        count += 1
      }
    }
  }
  console.log(count)
}
```

经过改造后，代码的结构由 3 层 for 循环，变成了 2 层 for 循环。很显然，时间复杂度就变成了$O(n^2)$ 。这样的代码改造，就是利用了方法论中的步骤二，将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。

再看第二个例子。查找出一个数组中，出现次数最多的那个元素的数值。例如，输入数组 a = \[1,2,3,4,5,5,6 \] 中，查找出现次数最多的数值。从数组中可以看出，只有 5 出现了 2 次，其余都是 1 次。显然 5 出现的次数最多，则输出 5。

工程师小明的解决方法是，采用两层的 for 循环完成计算。第一层循环，对数组每个元素遍历。第二层循环，则是对第一层遍历的数字，去遍历计算其出现的次数。这样，全局再同时缓存一个出现次数最多的元素及其次数就可以了。具体代码如下：

```js
function s1_7 () {
  const a = [1, 2, 3, 4, 5, 5, 6]
  let maxVal = -1
  let maxTime = 0
  let tmpTime = 0
  for (let i = 0; i < a.length; i++) {
    tmpTime = 0
    for (let j = i; j < a.length; j++) {
      if (a[j] === a[i]) {
        tmpTime++
      }
    }
    if (tmpTime > maxTime) {
      maxTime = tmpTime
      maxVal = a[i]
    }
  }
  console.log(maxVal)
}
```

在这段代码中，小明采用了两层的 for 循环，很显然时间复杂度就是 $O(n^2)$。而且代码中，几乎没有冗余的无效计算。如果还需要再去优化，就要考虑采用一些数据结构方面的手段，来把时间复杂度转移到空间复杂度了。

我们先想象一下，这个问题能否通过一次 for 循环就找到答案呢？一个直观的想法是，一次循环的过程中，我们同步记录下每个元素出现的次数。最后，再通过查找次数最大的元素，就得到了结果。

具体而言，定义一个 k-v 结构的字典，用来存放元素-出现次数的 k-v 关系。那么首先通过一次循环，将数组转变为元素-出现次数的一个字典。接下来，再去遍历一遍这个字典，找到出现次数最多的那个元素，就能找到最后的结果了。

![[Ciqc1F7E9eqAWr3gAFRNn2DsECQ086.gif]]

具体代码如下：

```js
function s1_8 () {
  const a = [1, 2, 3, 4, 5, 5, 6]
  const m = new Map()
  for (let i = 0; i < a.length; i++) {
    m.set(a[i], (m.get(a[i]) || 0) + 1)
  }
  let maxVal = -1
  let maxTime = 0
  for (const [key, val] of m.entries()) {
    if (val > maxTime) {
      maxTime = val
      maxVal = key
    }
  }
  console.log(maxVal)
}
```

我们来计算下这种方法的时空复杂度。代码结构上，有两个 for 循环。不过，这两个循环不是嵌套关系，而是顺序执行关系。其中，第一个循环实现了数组转字典的过程，也就是 $O(n)$ 的复杂度。第二个循环再次遍历字典找到出现次数最多的那个元素，也是一个 $O(n)$ 的时间复杂度。

因此，总体的时间复杂度为 $O(n) + O(n)$，就是 $O(2n)$，**根据复杂度与具体的常系数无关的原则**，也就是 $O(n)$ 的复杂度。空间方面，由于定义了 k-v 字典，其字典元素的个数取决于输入数组元素的个数。因此，空间复杂度增加为 $O(n)$。

这段代码的开发，就是借鉴了方法论中的步骤三，通过采用更复杂、高效的数据结构，完成了时空转移，提高了空间复杂度，让时间复杂度再次降低。

## 总结

复杂度通常包括时间复杂度和空间复杂度。在具体计算复杂度时需要注意以下几点。

1. **它与具体的常系数无关**，O(n) 和 O(2n) 表示的是同样的复杂度。
2. **复杂度相加的时候，选择高者作为结果**，也就是说 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。
3. **O(1) 也是表示一个特殊复杂度**，即任务与算例个数 n 无关。

复杂度细分为时间复杂度和空间复杂度，其中时间复杂度与**代码的结构设计**高度相关；空间复杂度与代码中**数据结构的选择**高度相关。

降低复杂度的方法就是三个步骤。只要你能深入理解这里的核心思想，就能把问题迎刃而解。

- 第一步，**暴力解法**。在没有任何时间、空间约束下，完成代码任务的开发。
- 第二步，**无效操作处理**。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
- 第三步，**时空转换**。设计合理数据结构，完成时间复杂度向空间复杂度的转移。
