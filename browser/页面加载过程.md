---
aliases: []
tags: ['browser','date/2022-03','year/2022','month/03']
date: 2022-03-04-Friday 10:22:12
update: 2022-03-04-Friday 11:41:06
---

## 浏览器页面加载过程

我们都知道，页面是用 HTML/CSS/JavaScript 来编写的。

其中，HTML 的职责在于告知浏览器如何组织页面，以及搭建页面的基本结构；

CSS 用来装饰 HTML，让我们的页面更好看；

JavaScript 则可以丰富页面功能，使静态页面动起来。

HTML由一系列的元素组成，通常称为HTML元素。HTML 元素通常被用来定义一个网页结构，基本上所有网页都是这样的 HTML 结构：

```html
<html>
  <head></head>
  <body></body>
</html>
```

其中：

`<html>`元素是页面的根元素，它描述完整的网页；

`<head>`元素包含了我们想包含在 HTML 页面中，但不希望显示在网页里的内容；

`<body>`元素包含了我们访问页面时所有显示在页面上的内容，是用户最终能看到的内容。

HTML 中的元素特别多，其中还包括可用于 Web Components 的自定义元素。

前面我们提到**页面 HTML 结构不合理可能会导致页面响应慢**，这个过程很多时候体现在`<script>`和`<style>`元素的设计上，它们会影响页面加载过程中对 Javascript 和 CSS 代码的处理。

因此，如果想要提升页面的加载速度，就需要了解浏览器页面的加载过程是怎样的，从根本上来解决问题。

浏览器在加载页面的时候会用到 GUI 渲染线程和 JavaScript 引擎线程。其中，GUI 渲染线程负责渲染浏览器界面 HTML 元素，JavaScript 引擎线程主要负责处理 JavaScript 脚本程序。

由于 JavaScript 在执行过程中还可能会改动界面结构和样式，因此它们之间被设计为互斥的关系。也就是说，当 JavaScript 引擎执行时，GUI 线程会被挂起。

我们来看看网页加载流程。

1. 当我们打开网页的时候，浏览器会从服务器中获取到 HTML 内容。
2. 浏览器获取到 HTML 内容后，就开始从上到下解析 HTML 的元素。
3. `<head>`元素内容会先被解析，此时浏览器还没开始渲染页面。
>我们看到`<head>`元素里有用于描述页面元数据的`<meta>`元素，还有一些`<link>`元素涉及外部资源（如图片、CSS 样式等），此时浏览器会去获取这些外部资源。
>除此之外，我们还能看到`<head>`元素中还包含着不少的`<script>`元素，这些`<script>`元素通过src属性指向外部资源。
4. 当浏览器解析到这里时（步骤 3），会暂停解析并下载 JavaScript 脚本。
5. 当 JavaScript 脚本下载完成后，浏览器的控制权转交给 JavaScript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 HTML 页面。
6. `<body>`元素内容开始被解析，浏览器开始渲染页面。

在这个过程中，我们看到`<head>`中放置的`<script>`元素会阻塞页面的渲染过程：把 JavaScript 放在`<head>`里，意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面。

到这里，我们就明白了：如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕。

因此，对于对性能要求较高、需要快速将内容呈现给用户的网页，常常会将 JavaScript 脚本放在`<body>`的最后面。这样可以避免资源阻塞，页面得以迅速展示。我们还可以使用`defer/async/preload`等属性来标记`<script>`标签，来控制 JavaScript 的加载顺序。

再来看看百度首页。

![](_attachment/img/Pasted image 20220304112429.png)

可以看到，虽然百度首页的`<head>`元素里也包括了一些`<script>`元素，但大多数都加上了async属性。async属性会让这些脚本并行进行请求获取资源，同时当资源获取完成后尽快解析和执行，这个过程是异步的，不会阻塞 HTML 的解析和渲染。

对于百度这样的搜索引擎来说，必须要在最短的时间内提供到可用的服务给用户，其中就包括搜索框的显示及可交互，除此之外的内容优先级会相对较低。

浏览器在渲染页面的过程需要解析 HTML、CSS 以得到 DOM 树和 CSS 规则树，它们结合后才生成最终的渲染树并渲染。因此，我们还常常将 CSS 放在`<head>`里，可用来避免浏览器渲染的重复计算。

## DOM 解析

我们常见的 HTML 元素，在浏览器中会被解析成节点。比如下面这样的 HTML 内容：

```html
<html>
  <head>
    <title>文档标题</title>
  </head>
  <body>
    <a href="xx.com/xx">我的链接</a>
    <h1>我的标题</h1>
  </body>
</html>
```

打开控制台 Elements 面板，可以看到这样的 HTML 结构，如下图所示：

![](_attachment/img/Cgp9HWBv-1GAHK67AAAuHUpDrAg091.png)

在浏览器中，上面的 HTML 会被解析成这样的 DOM 树，如下图所示：

![](_attachment/img/Cgp9HWBwLYmAP2m9AAB9VgDwVDs760.png)

我们都知道，对于树状结构来说，常常使用`parent/child/sibling`等方式来描述各个节点之间的关系，对于 DOM 树也不例外。或许对于很多前端开发者来说，“DOM 是树状结构”已经是个过于基础的认识，因此我们也常常忽略掉开发过程中对它的依赖程度。

举个例子，我们常常会对页面功能进行抽象，并封装成组件。但不管怎么进行整理，页面最终依然是基于 DOM 的树状结构，因此组件也是呈树状结构，组件间的关系也同样可以使用`parent/child/sibling`这样的方式来描述。

同时，现在大多数应用程序同样以root为根节点展开，我们进行状态管理、数据管理也常常会呈现出树状结构，这在 Angular.js 升级到 Angular 的过程中也有所体现。Angular 增加了树状结构的模块化设计，不管是脏检查机制，还是依赖注入的管理，都由于这样的调整提升了性能、降低了模块间的耦合程度。
