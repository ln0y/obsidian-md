---
aliases: []
tags: ['browser', 'date/2023-10', 'year/2023', 'month/10']
date: 2023-10-10-星期二 19:36:48
update: 2023-10-11-星期三 20:42:29
---

## 浏览器通信方式

每个浏览器标签页通常被视为一个独立的进程，而不是一个线程。这种多进程架构被称之为多进程浏览器，谷歌浏览器就是采用这种方式。

这种架构的方式的主要目的是提高浏览器的稳定性、安全性和性能。

在多进程浏览器中，每个标签页都独立运行在独立的进程中，这样一旦一个标签页崩溃或遇到问题，不会影响其他标签页和浏览器本身的稳定性。而每个进程都有属于自己的内存。

在多进程浏览器中，不同标签页之间的通信是通过进程间通信 `IPC` 机制来实现的。`IPC` 是操作系统提供的一种机制，允许不同进程之间交换数据和消息，从而实现协同工作。

在操作系统中，著有有以下几种通信方式：

1. 基于管道的通信：
   - 管道是一种半双工的通信机制，可用于同一父进程与其子进程之间通信，或者用于同一计算机上的不同进程之间通信。
   - 命名管道提供了进程间进行双向通信的能力。可以被多个进程打开和使用。其中一个进程将数据写入管道，而另一个进程则可以从管道中读取这些数据。命名管道通常用于在不相关的进程之间传递数据，比如客户端和服务器之间的通信。
   - 匿名管道是一种用于单向通信的机制，仅用于具有父子关系的进程之间。它只能在创建时通过操作系统提供的机制进行传递。匿名管道在创建时自动建立，并且只能用于具有亲缘关系的进程之间的通信。其中一个进程将数据写入管道的写端，而另一个进程则从管道的读端读取这些数据。
2. 消息队列： 消息队列允许进程通过将消息放入队列中来进行通信。进程可以从队列中接收消息，实现异步通信。消息队列适用于不需要直接的点对点连接的场景，而且可以在不同计算机之间通信。
3. 共享内存： 共享内存允许多个进程访问同一块物理内存区域，从而实现高效的数据共享。进程可以在共享内存中读写数据，而不需要显式的数据传输操作。
4. 套接字 `Socket`：套接字通信是一种在计算机网络中实现进程间通信的方式。它基于网络协议栈，使用 TCP 或 UDP 等传输层协议，在不同的主机之间进行数据传输和通信。
5. Remote Procedure Call： RPC 允许一个进程通过网络请求调用另一个进程中的函数，就像调用本地函数一样。远程过程调用隐藏了底层通信细节，使得进程间通信更加方便。
6. 信号（Signal）：信号通信是一种在操作系统中实现进程间通信的机制。它允许一个进程向另一个进程发送信号，用于通知、中断或请求处理等目的。它是一种异步事件，当某个事件发生时，操作系统会向进程发送相应的信号。进程可以事先注册信号处理函数来捕获并处理这些信号。

## JavaScript 如何实现跨标签页通信

### [BroadcastChannel](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel)

BroadcastChannel 通信的方式原理就是一个命名管道。它允许让指定的**同源**下浏览器不同的窗口来订阅它。

每个 BroadcastChannel 对象都需要使用一个唯一的名称来标识通道，这个名称在同一域名下的不同页面之间必须是唯一的。它允许同一域名下的不同页面之间进行通信。

```js
const broad = new BroadcastChannel('moment')
```

通过 postMessage 方法，一个页面可以将消息发送到频道中，而其他页面则可以监听 message 事件来接收这些消息。通过这种方式是短线了一种实时通信的机制，可以在不同的页面之间传递信息，实现页面间的即时交流。如下图所示：

![20230823064028](_attachment/img/3b44d4ffe9919ab03b0f3e8d7f912ba6_MD5.png)

BroadcastChannel 的类型定义有如下代码所示：

```ts
[Exposed=(Window,Worker)]
interface BroadcastChannel : EventTarget {
  constructor(DOMString name);

  readonly attribute DOMString name;
  undefined postMessage(any message);
  undefined close();
  attribute EventHandler onmessage;
  attribute EventHandler onmessageerror;
};
```

要想使用，首先我们创建 html 文件代表页面，并且使用 live server 开启一个本地服务器：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>BroadCast Channel</title>
  </head>
  <body>
    <input
      id="inp"
      type="text"
    />
    <button id="sendBtn">send</button>
    <div id="receiveList"></div>
    <button id="closeBtn">close</button>
  </body>
  <script>
    const bc = new BroadcastChannel('Broadcast')
    function message(text) {
      const msg = document.createElement('div')
      msg.appendChild(document.createTextNode(text))
      receiveList.appendChild(msg)
    }
    bc.onmessage = function (e) {
      message(`receive: ${e.data}`)
    }
    // bc.onmessageerror = function (e) {
    //   message('error:', e)
    // }
    sendBtn.onclick = function () {
      message(`send: ${inp.value}`)
      bc.postMessage(inp.value)
    }
    closeBtn.onclick = bc.close.bind(bc)
  </script>
</html>
```

通过 postMessage 向管道中发送消息，当管道中存在消息的时候，可以通过 onmessage 方法获取到信息内容。

### [Service Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)

[Service Worker](browser/ServiceWorker.md) 它是一种服务工作线程，是一种在浏览器背后运行的脚本，用于处理网络请求和缓存等任务。它是一种在浏览器与网络之间的中间层，允许开发者拦截和控制页面发出的网络请求，以及管理缓存，从而实现离线访问、性能优化和推送通知等功能。

它在浏览器背后独立运行与网页分开，这意味着即使用户关闭了网页，Service Worker 仍然可以运行。可以用于实现推送通知功能。它可以注册为推送消息的接收者，当服务器有新的通知要发送时，Service Worker 可以显示通知给用户，即使网页没有打开。

要想使用，首先我们创建 html 文件代表页面，创建一个 Service Worker 文件，并且使用 live server 开启一个本地服务器：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Service Worker</title>
  </head>
  <body>
    <input
      id="inp"
      type="text"
    />
    <button id="sendBtn">send</button>
    <div id="receiveList"></div>
    <button id="closeBtn">close</button>
  </body>
  <script>
    function message(text) {
      const msg = document.createElement('div')
      msg.appendChild(document.createTextNode(text))
      receiveList.appendChild(msg)
    }

    if ('serviceWorker' in navigator) {
      const sw = navigator.serviceWorker
      sw.register('./sw.js').then(reg => {
        console.log('Service Worker Registered', reg)
      })
      sw.addEventListener('message', function (e) {
        message(`receive: ${e.data}`)
      })
      sendBtn.addEventListener('click', function () {
        message(`send: ${inp.value}`)
        sw.controller.postMessage(inp.value)
      })
    }
  </script>
</html>
```

创建一个 worker.js 文件并编写以下代码：

```js
// worker.js
self.addEventListener('message', function (e) {
  console.log('service worker receive message', e.data)
  e.waitUntil(
    self.clients.matchAll().then(function (clients) {
      if (!clients || clients.length === 0) {
        return
      }
      clients.forEach(function (client) {
        client.postMessage(e.data)
      })
    })
  )
})
```

我们在 Service Worker 中监听了 `message` 事件，获取页面（从 Service Worker 的角度叫 client）发送的信息。然后通过 `self.clients.matchAll()` 获取当前注册了该 Service Worker 的所有页面，通过调用每个 client（即页面）的 `postMessage` 方法，向页面发送消息。这样就把从一处（某个 Tab 页面）收到的消息通知给了其他页面。

你所编写的 Service Worker 将遵守以下生命周期：

1. 注册: 在网页的 JavaScript 代码中调用 navigator.serviceWorker.register() 方法来注册一个 Service Worker;
2. 安装: 当 Service Worker 文件被下载并首次运行时，会触发 install 事件。在 install 事件中，你可以缓存静态资源，如 HTML、CSS、JavaScript 文件，以便在离线时使用;
3. 激活: 安装成功后，Service Worker 并不会立即接管页面的网络请求。它需要等到之前的所有页面都关闭，或者在下次页面加载时才会激活 ();
4. 控制: 一旦 Service Worker 被激活，它就开始控制在其作用域内的页面。它可以拦截页面发出的网络请求，并根据缓存策略返回缓存的内容;
5. 更新: 当你更新 Service Worker 文件并再次注册时，会触发一个新的 install 事件。你可以在新的 install 事件中更新缓存，然后在下次页面加载时进行激活，以确保新的 Service Worker 被使用;
6. 解除注册: 如果你不再需要 Service Worker，可以通过调用 `navigator.serviceWorker.unregister()` 来解除注册;

它本身是一个由 promise 封装的对象，未初始化时是一个 pending 状态的，当成功注册之后会变成 fulfilled。

### [LocalStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)

LocalStorage 作为前端最常用的本地存储，大家应该已经非常熟悉了；但 [`StorageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent) 这个与它相关的事件有些同学可能会比较陌生。

当 LocalStorage 变化时，会触发 `storage` 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 `storage` 事件即可收到通知。

编写如下代码：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>LocalStorage</title>
  </head>
  <body>
    <input
      id="inp"
      type="text"
    />
    <button id="sendBtn">send</button>
    <div id="receiveList"></div>
    <button id="closeBtn">close</button>
  </body>
  <script>
    function message(text) {
      const msg = document.createElement('div')
      msg.appendChild(document.createTextNode(text))
      receiveList.appendChild(msg)
    }
    window.addEventListener('storage', function (e) {
      if (e.key === 'message') {
        message(`receive: ${e.newValue}`)
      }
    })
    sendBtn.addEventListener('click', function () {
      localStorage.setItem('message', inp.value)
      message(`send: ${inp.value}`)
    })
  </script>
</html>
```

### [Shared Worker](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker)

Shared Worker  是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。

Shared Worker 在实现跨页面通信时的问题在于，它无法主动通知所有页面，因此，我们可以把所有连接存起来进行广播。思路如下：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Shared Worker</title>
  </head>
  <body>
    <input
      id="inp"
      type="text"
    />
    <button id="sendBtn">send</button>
    <div id="receiveList"></div>
    <button id="closeBtn">close</button>
  </body>
  <script>
    function message(text) {
      const msg = document.createElement('div')
      msg.appendChild(document.createTextNode(text))
      receiveList.appendChild(msg)
    }

    const sharedWorker = new SharedWorker('SharedWorker.js')

    // 监听 get 消息的返回数据
    sharedWorker.port.addEventListener('message', e => {
      message(`receive: ${e.data}`)
    })
    sharedWorker.port.start()

    sendBtn.addEventListener('click', function () {
      message(`send: ${inp.value}`)
      sharedWorker.port.postMessage(inp.value)
    })

    // 通知关闭与 shared worker 的连接
    window.addEventListener('beforeunload', function () {
      sharedWorker.port.postMessage('close')
    })
  </script>
</html>
```

```js
console.log('SharedWorker is running')
const ports = new Set()
self.addEventListener('connect', function (e) {
  const port = e.ports[0]
  // 将新的连接存起来
  ports.add(port)
  port.addEventListener('message', function (event) {
    const { data } = event
    if (data === 'close') {
      // 关闭连接，移除对应 port
      ports.delete(port)
    } else {
      // 向当前所有连接了的 port 广播消息
      boardcast(data)
    }
  })
  port.start()
})

function boardcast(message) {
  for (const port of ports) {
    port.postMessage(message)
  }
}
```

注意，如果使用 addEventListener 来添加 Shared Worker 的消息监听，需要显式调用 MessagePort.start 方法，即上文中的 sharedWorker.port.start()；如果使用 onmessage 绑定监听则不需要。

> 调试 Shared Worker 需要打开 chrome://inspect/#workers

### [IndexDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)

IndexedDB 是一种在浏览器中用于存储和管理大量结构化数据的 Web API。它提供了一种持久性存储解决方案，允许 Web 应用程序在客户端存储数据，以便在不同会话、页面加载或浏览器关闭之间保留数据。

与传统的 cookie 或 localStorage 等存储方式不同，IndexedDB 更适合存储复杂的、结构化的数据，例如对象、数组、键值对等。这使得它特别适用于应用程序需要存储大量数据、执行高级查询或支持离线工作的情况。

其思路很简单：消息发送方将消息存至 IndexedDB 中；接收方（例如所有页面）则通过轮询去获取最新的信息。在这之前，我们先简单封装几个 IndexedDB 的工具方法。

- 打开数据库连接：

```js
function openStore() {
  const storeName = 'ctc_aleinzhou'
  return new Promise(function (resolve, reject) {
    if (!('indexedDB' in window)) {
      return reject("don't support indexedDB")
    }
    const request = indexedDB.open('CTC_DB', 1)
    request.onerror = reject
    request.onsuccess = e => resolve(e.target.result)
    request.onupgradeneeded = function (e) {
      const db = e.srcElement.result
      if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {
        const store = db.createObjectStore(storeName, { keyPath: 'tag' })
        store.createIndex(storeName + 'Index', 'tag', { unique: false })
      }
    }
  })
}
```

- 存储数据

```js
function saveData(db, data) {
  return new Promise(function (resolve, reject) {
    const STORE_NAME = 'ctc_aleinzhou'
    const tx = db.transaction(STORE_NAME, 'readwrite')
    const store = tx.objectStore(STORE_NAME)
    const request = store.put({ tag: 'ctc_data', data })
    request.onsuccess = () => resolve(db)
    request.onerror = reject
  })
}
```

- 查询/读取数据

```js
function query(db) {
  const STORE_NAME = 'ctc_aleinzhou'
  return new Promise(function (resolve, reject) {
    try {
      const tx = db.transaction(STORE_NAME, 'readonly')
      const store = tx.objectStore(STORE_NAME)
      const dbRequest = store.get('ctc_data')
      dbRequest.onsuccess = e => resolve(e.target.result)
      dbRequest.onerror = reject
    } catch (err) {
      reject(err)
    }
  })
}
```

剩下的工作就非常简单了。首先打开数据连接，并初始化数据：

```js
openStore().then(db => saveData(db, null))
```

对于消息读取，可以在连接与初始化后轮询：

```js
openStore()
  .then(db => saveData(db, null))
  .then(function (db) {
    setInterval(function () {
      query(db).then(function (res) {
        if (!res || !res.data) {
          return
        }
        const data = res.data
        const text = '[receive] ' + data.msg + ' —— tab ' + data.from
        console.log('[Storage I] receive message:', text)
      })
    }, 1000)
  })
```

最后，要发送消息时，只需向 IndexedDB 存储数据即可：

```js
openStore()
  .then(db => saveData(db, null))
  .then(function (db) {
    // …… 省略上面的轮询代码
    // 触发 saveData 的方法可以放在用户操作的事件监听内
    saveData(db, mydata)
  })
```

要实现跨标签通信,如下代码所示:

```html
<!-- a.html -->
<script>
  let index = 0
  // 打开或创建 IndexedDB 数据库
  const request = indexedDB.open('database', 1)

  request.onupgradeneeded = event => {
    const db = event.target.result
    const objectStore = db.createObjectStore('dataStore', {
      keyPath: 'key',
    })
  }

  request.onsuccess = event => {
    const db = event.target.result
    const transaction = db.transaction(['dataStore'], 'readwrite')
    const objectStore = transaction.objectStore('dataStore')

    // 存储数据

    objectStore.put({ key: 'supper', value: `moment` })

    transaction.oncomplete = () => {
      db.close()
    }
  }
</script>

<!-- b.html -->
<script>
  // 打开相同的 IndexedDB 数据库
  const request = indexedDB.open('database', 1)

  request.onsuccess = event => {
    const db = event.target.result
    const transaction = db.transaction(['dataStore'], 'readonly')
    const objectStore = transaction.objectStore('dataStore')

    // 获取数据
    const getRequest = objectStore.get('supper')

    getRequest.onsuccess = event => {
      const data = event.target.result
      if (data) {
        console.log(data.value)
      }
    }

    transaction.oncomplete = () => {
      db.close()
    }
  }
</script>
```

### cookie

cookie 的话没什么好讲的，直接上代吧：

```html
<!-- a.html -->
<script>
  let index = 0
  setInterval(() => {
    document.cookie = `supper=moment ${index++}`
  }, 1000)
</script>

<!-- b.html -->
<script>
  console.log('cookie 的值为: ', document.cookie)

  setInterval(() => {
    console.log('cookie 的值发生了变化: ', document.cookie)
  }, 1000)
</script>
```

具体代码运行效果如下图所示：

![动画.gif](_attachment/img/f192d2c0de8a0a7cce4d54db82fc22fa_MD5.gif)

### postMessage

window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有同源时，这两个脚本才能相互通信。

```html
<!-- a.html -->
<body>
  <button class="pop">弹出新窗口</button>
  <button class="button">发送数据</button>
  <script>
    const pop = document.querySelector('.pop')
    const button = document.querySelector('.button')

    let index = 0
    let opener = null

    pop.addEventListener('click', () => {
      opener = window.open('b.html', '123', 'height=600,width=600,top=20,resizeable=yes')
    })

    button.addEventListener('click', () => {
      const data = {
        value: `moment ${index++}`,
      }

      opener.postMessage(data, '*')
    })
  </script>
</body>

<!-- b.html -->
<body>
  <div>moment</div>
  <script>
    window.addEventListener('message', e => {
      console.log(e.data)
    })
  </script>
</body>
```

通过点击按钮在主窗口和弹出的新窗口之间进行通信。通过 postMessage，主窗口可以向新窗口发送数据，从而实现了简单的跨窗口通信。在实际应用中，你可以在接收消息的窗口中监听 message 事件，然后在事件处理程序中处理接收到的数据。

具体代码运行效果如下图所示：

![动画.gif](_attachment/img/66357a90f02724310a27013603fff80f_MD5.gif)
