---
aliases: []
tags: ['JavaScript','date/2022-03','year/2022','month/03']
date: 2022-03-04-Friday 13:53:31
update: 2022-03-04-Friday 13:55:59
---

我们知道，浏览器中各个元素从页面中接收事件的顺序包括事件捕获阶段、目标阶段、事件冒泡阶段。其中，基于事件冒泡机制，我们可以实现将子元素的事件委托给父级元素来进行处理，这便是事件委托。

如果我们需要监听滚动控制面板中的几个文本被点击，从而控制广告面板的展示内容，如下图所示：

![[CioPOWBwLZmAbHu7AAD6mAT107Y372.png|800]]

如果我们在每个元素上都进行监听的话，则需要绑定三个事件。

```js
function clickEventFunction(e) {
  console.log(e.target === this); // logs `true`
  // 这里可以用 this 获取当前元素
  // 此处控制广告面板的展示内容
}
// 元素2、5、8绑定
element2.addEventListener("click", clickEventFunction, false);
element5.addEventListener("click", clickEventFunction, false);
element8.addEventListener("click", clickEventFunction, false);
```

使用事件委托，可以通过将事件添加到它们的父节点，而将事件委托给父节点来触发处理函数：

```js
function clickEventFunction(event) {
  console.log(e.target === this); // logs `false`
  // 获取被点击的元素
  const eventTarget = event.target;
  // 检查源元素`event.target`是否符合预期
  // 此处控制广告面板的展示内容
}
// 元素1绑定
element1.addEventListener("click", clickEventFunction, false);
```

这样能解决什么问题呢？

- 绑定子元素会绑定很多次的事件，而绑定父元素只需要一次绑定。
- 将事件委托给父节点，这样我们对子元素的增加和删除、移动等，都不需要重新进行事件绑定。

常见的使用方式主要是上述这种列表结构，每个选项都可以进行编辑、删除、添加标签等功能，而把事件委托给父元素，不管我们新增、删除、更新选项，都不需要手动去绑定和移除事件。

如果在列表数量内容较大的时候，对成千上万节点进行事件监听，也是不小的性能消耗。**使用事件委托的方式，我们可以大量减少浏览器对元素的监听，也是在前端性能优化中比较简单和基础的一个做法。**

需要注意的是，如果我们直接在 `document.body`上进行事件委托，可能会带来额外的问题。由于浏览器在进行页面渲染的时候会有合成的步骤，合成的过程会先将页面分成不同的合成层，而用户与浏览器进行交互的时候需要接收事件。此时，浏览器会将页面上具有事件处理程序的区域进行标记，被标记的区域会与主线程进行通信。

如果我们 `document.body`上被绑定了事件，这时候整个页面都会被标记。即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。这种情况，我们可以使用 `passive: true` 选项来解决。
