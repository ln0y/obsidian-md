---
aliases: []
tags: ['js/extends','JavaScript','date/2022-02','year/2022','month/02']
date: 2022-02-25-Friday 17:24:01
update: 2022-03-15-Tuesday 16:14:20
---

## 继承的概念

说到继承的概念，首先要说一个经典的例子。

先定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等，由汽车这个类可以派生出“轿车”和“货车”两个类，那么可以在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱。这样轿车和货车就是不一样的，但是二者都属于汽车这个类，这样从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系。

继承可以使得子类别具有父类的各种方法和属性，比如上面的例子中“轿车” 和 “货车” 分别继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性。在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法。

## JS 实现继承的几种方式

### 原型链继承

原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。

```js
function Parent () {
  this.name = 'parent'
  this.play = [1, 2, 3]
}
function Child () {
  this.type = 'child'
}
Child.prototype = new Parent()
console.log(new Child())
```

上面的代码看似没有问题，虽然父类的方法和属性都能够访问，但其实有一个潜在的问题，我再举个例子来说明这个问题。

```js
var s1 = new Child()
var s2 = new Child()
s1.play.push(4)
console.log(s1.play) // [1,2,3,4]
console.log(s2.play) // [1,2,3,4]
```

两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。

问题：

- 包含引用类型值的原型属性会被所有实例共享
- 在创建子类的实例时，不能父类的构造函数传参

### 借用构造函数继承（借助 call）

```js
function Parent (name) {
  // 每次创建实例都会创建一遍方法
  this.name = name
}

Parent.prototype.getName = function () {
  return this.name
}

function Child () {
  Parent.call(this, 'parent')
  this.age = 29
}

const child = new Child()

console.log(child.name, child.age) // parent 29
console.log(child.getName()) // Uncaught TypeError: child.getName is not a function
```

这样写的时候子类虽然能够拿到父类的属性值，解决了第一种继承方式的弊端，但问题是，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法。

从上面的结果就可以看到构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。

问题：

- 继承不到父类原型上的属性和方法
- 方法都在构造函数中定义，每次创建实例都会创建一遍方法

### 组合继承（前两种组合）

这种方式结合了前两种继承方式的优缺点，结合起来的继承。

```js
function Parent(name) {
  this.name = name
}

Parent.prototype.getName = function () {
  return this.name
}

function Child(name, age) {
  // 第二次调用构造函数 Parent
  Parent.call(this, name)
  this.age = age
}

// 第一次调用构造函数 Parent
Child.prototype = new Parent()
// 手动挂上构造器，指向自己的构造函数
Child.prototype.constructor = Child
// 实现子类原型方法
Child.prototype.getAge = function () {
  return this.age
}

const child1 = new Child('cat', 18)
const child2 = new Child('dog', 20)

console.log(child1.getAge(),child1.getName()) // 18 'cat'
console.log(child2.getAge(),child2.getName()) // 20 'dog'
```

执行上面的代码，可以看到之前方法一和方法二的问题都得以解决。

但是这里又增加了一个新问题：通过注释我们可以看到 Parent 执行了两次，第一次是改变Child 的 prototype 的时候，第二次是通过 call 方法调用 Parent 的时候，那么 Parent 多构造一次就多进行了一次性能开销，这是我们不愿看到的。

问题：

- 每次创建子类实例都会造成实例原型中会存在两份相同的属性和方法
- 子类实例时 Parent 构造函数会被调用 2 次

### 原型式继承

这里不得不提到的就是 ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。

![[Object.create]]

这就是 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

```js
let parent = {
  name: "parent",
  friends: ["p1", "p2", "p3"],
  getName: function () {
    return this.name
  }
}

let person1 = Object.create(parent)
person1.name = "tom"
person1.friends.push("jerry")

let person2 = Object.create(parent)
person2.friends.push("lucy")

console.log(person1.name) // tom
console.log(person1.name === person1.getName()) // true
console.log(person2.name) // parent
console.log(person1.friends) // ['p1', 'p2', 'p3', 'jerry', 'lucy']
console.log(person2.friends) // ['p1', 'p2', 'p3', 'jerry', 'lucy']
```

那么关于这种继承方式的缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能。

问题： 包含引用类型值的原型属性会被所有实例共享，与原型链继承一样

### 寄生式继承

使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。

虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。

```js
let parent = {
  name: "parent",
  friends: ["p1", "p2", "p3"],
  getName: function () {
    return this.name
  }
}

function createAnother (o) {
  let clone = Object.create(o)
  // 每次创建实例都会创建一遍方法
  clone.sayHi = function () {
    console.log('hi')
  }
  return clone
}

let person = createAnother(parent)

console.log(person.getName()) // parent
console.log(person.sayHi()) // hi

```

问题： 跟借用构造函数模式一样，每次创建对象都会创建一遍方法

### 寄生组合式继承

结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式。

> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。《JavaScript 高级程序设计》

es6 的继承会被编译为寄生组合式继承

```js
function Parent(name) {
  this.name = name
}

Parent.getOne = function () {
  return 1
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

// function objectCreate(o) {
//   function F() {}
//   F.prototype = o
//   return new F()
// }

// function inheritPrototype(child, parent) {
//   var prototype = objectCreate(parent.prototype)
//   prototype.constructor = child
//   child.prototype = prototype
// }

// inheritPrototype(Child, Parent)

// 用Object.create实现以上注释部分
Child.prototype = Object.create(Parent.prototype, {
  constructor: { // 修复 constructor
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
})

// 静态属性继承
Object.setPrototypeOf(Child, Parent)

Child.prototype.getAge = function () {
  return this.age
}

var child = new Child('kevin', '18')
```

^fe658c

```js
function inherit (Child, Parent) {
  // 继承原型上的属性 
  Child.prototype = Object.create(Parent.prototype, {
    constructor: {// 修复 constructor
      value: Child,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  })

  // 存储超类
  Child.super = Parent
  // 静态属性继承
  if (Object.setPrototypeOf) {
    // setPrototypeOf es6
    Object.setPrototypeOf(Child, Parent)
  } else if (Child.__proto__) {
    // __proto__ es6 引入，但是部分浏览器早已支持
    Child.__proto__ = Parent
  } else {
    // 兼容 IE10 等陈旧浏览器
    // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
    for (var k in Parent) {
      if (Parent.hasOwnProperty(k) && !(k in Child)) {
        Child[k] = Parent[k]
      }
    }
  }
}
```

^d5270b

## ES6 的 extends 关键字实现逻辑

我们可以利用 ES6 里的 extends 的语法糖，使用关键词很容易直接实现 JavaScript 的继承，但是如果想深入了解 extends 语法糖是怎么实现的，就得深入研究 extends 的底层逻辑。

我们先看下用利用 extends 如何直接实现继承，代码如下：

```js
class Person {
  constructor (name) {
    this.name = name
  }
  // 原型方法
  // 即 Person.prototype.getName = function() { }
  // 下面可以简写为 getName() {...}
  getName = function () {
    console.log('Person:', this.name)
  }
}
class Gamer extends Person {
  constructor (name, age) {
    // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
    super(name)
    this.age = age
  }
}
const asuna = new Gamer('Asuna', 20)
asuna.getName() // 成功访问到父类的方法
```

因为浏览器的兼容性问题，如果遇到不支持 ES6 的浏览器，那么就得利用 babel 这个编译工具，将 ES6 的代码编译成 ES5，让一些不支持新语法的浏览器也能运行。

那么最后 extends 编译成了什么样子呢？我们看一下转译之后的代码片段：

```js
// 处理构造函数返回值
function _possibleConstructorReturn (self, call) {
  // ...
  return call && (typeof call === 'object' || typeof call === 'function') ? call : self
}
function _classCallCheck (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}
// 实现继承
function _inherits (subClass, superClass) {
  // 这里可以看到
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  })
  Object.defineProperty(subClass, 'prototype', { writable: false })
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass
}

var Parent = function Parent () {
  // 验证是否是 Parent 构造出来的 this
  _classCallCheck(this, Parent)
}
var Child = (function (_Parent) {
  _inherits(Child, _Parent)
  function Child () {
    _classCallCheck(this, Child)
    return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments))
  }
  return Child
}(Parent))
```

从上面编译完成的源码中可以看到，它采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式。

## 类继承和原型继承的区别

我们已经了解了 JavaScript 中的原型继承，那么它和传统面向对象语言的类继承有什么不同呢？这就涉及编程语言范畴了，传统的面向对象语言的类继承，会引发一些问题：

- 紧耦合问题
- 脆弱基类问题
- 层级僵化问题
- 必然重复性问题
- 大猩猩—香蕉问题

以上这些内容属于纯理论，下面借用 Eric Elliott 的著名文章“[Difference between class prototypal inheritance](https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9?utm_source=tuicool&utm_medium=referral)”，来展开说明类继承和原型继承的优劣。我们先看下图：

![[CioPOWAs1oqAK7n6AAD_bt3FABw414.png|800]]

通过上图，我们看出一些问题（单一继承、紧耦合以及层级分类问题），对于类 8，只想继承五边形的属性，却得到了继承链上其他并不需要的属性，比如五角星，正方形属性。这就是大猩猩/香蕉问题，“我只想要一个香蕉，但是你给我了整个森林”。

对于类 9，对比其父类，我只需要把五角星属性修改成四角星，但是五角星继承自基类 1，如果要去修改，那就会影响整个继承树（脆弱基类/层级僵化问题）；好吧，我不去修改，那就需要给类 9 新建一个基类（必然重复性问题）。

那么基于原型的继承如何解决上述问题呢？

![[CioPOWAs1quAXIdzAC9wcK4g428951.gif|800]]

采用原型继承，其实**本质是对象组合**，可以避免复杂纵深的层级关系。当类 1 需要四角星特性的时候，只需要组合新特性即可，不会影响到其他实例。
