---
aliases: []
tags: ['js/array','js/push','js/pop','js/map','js/reduce','JavaScript','date/2022-03','year/2022','month/03']
date: 2022-03-01-Tuesday 17:14:15
update: 2022-03-01-Tuesday 17:45:01
---

## push 方法的底层实现

为了更好地实现 push 的底层方法，你可以先去 ECMA 的官网去查一下关于 push 的基本描述（链接：[ECMA 数组的 push 标准](https://tc39.es/ecma262/#sec-array.prototype.push)），我们看下其英文的描述，如下所示。

```plain
When the push method is called with zero or more arguments, the following steps are taken:
1. Let O be ? ToObject(this value).
2. Let len be ? LengthOfArrayLike(O).
3. Let argCount be the number of elements in items.
4. If len + argCount > 2^53 - 1, throw a TypeError exception.
5. For each element E of items, do
  a. Perform ? Set(O, ! ToString(F(len)), E, true).
  b. Set len to len + 1.
6. Perform ? Set(O, "length", F(len), true).
7. Return F(len).
```

从上面的描述可以看到边界判断逻辑以及实现的思路，根据这段英文，我们将其转换为容易理解代码，如下所示。

![](_attachment/img/Array.prototype.push)

从上面的代码可以看出，关键点就在于给数组本身循环添加新的元素 item，然后调整数组的长度 length 为最新的长度，即可完成 push 的底层实现。

无符号右移，最大值就是32位的全1，即$2^{32}-1$ // 4294967295，所以如果是最大安全数无符号右移0位后，应该是`2 ** 53 - 1 >>> 0 === 2 ** 32 - 1 // true`，假设len、argCount都是最大安全数，即`(2 ** 53 - 1 >>> 0) + (2 ** 53 - 1 >>> 0) === (2 ** 32 - 1) *2 // true`。得len+argCount永远无法大于`2 ** 53 - 1`。

## pop 方法的底层实现

同样我们也一起来看下 pop 的底层实现，你也可以先去 ECMA 的官网去查一下关于 pop 的基本描述（链接：[ECMA 数组的 pop 标准](https://tc39.es/ecma262/#sec-array.prototype.pop)），我们还是同样看下英文的描述。

```plain
When the pop method is called, the following steps are taken:
1. Let O be ? ToObject(this value).
2. Let len be ? LengthOfArrayLike(O).
3. If len = 0, then
    Perform ? Set(O, "length", +0F, true).
    Return undefined.
4. Else,
  Assert: len > 0.
  Let newLen be F(len - 1).
  Let index be ! ToString(newLen).
  Let element be ? Get(O, index).
  Perform ? DeletePropertyOrThrow(O, index).
  Perform ? Set(O, "length", newLen, true).
  Return element.
```

从上面的描述可以看到边界判断逻辑以及实现的思路，根据上面的英文，我们同样将其转换为可以理解的代码，如下所示。

![](_attachment/img/Array.prototype.pop)

其核心思路还是在于删掉数组自身的最后一个元素，index 就是数组的 len 长度，然后更新最新的长度，最后返回的元素的值，即可达到想要的效果。另外就是在当长度为 0 的时候，如果执行 pop 操作，返回的是 undefined，需要做一下特殊处理。

## map 方法的底层实现

同样你可以去 ECMA 的官网去查一下关于 map 的基本描述（链接：[ECMA 数组的 map 标准](https://tc39.es/ecma262/#sec-array.prototype.map)），请看英文的表述。

```plain
When the map method is called with one or two arguments, the following steps are taken:
1. Let O be ? ToObject(this value).
2. Let len be ? LengthOfArrayLike(O).
3. If IsCallable(callbackfn) is false, throw a TypeError exception.
4. Let A be ? ArraySpeciesCreate(O, len).
5. Let k be 0.
6. Repeat, while k < len,
    a. Let Pk be ! ToString(F(k)).
    b. Let kPresent be ? HasProperty(O, Pk).
    c. If kPresent is true, then
        Let kValue be ? Get(O, Pk).
        Let mappedValue be ? Call(callbackfn, thisArg, « kValue, F(k), O »).
        Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).
    d. Set k to k + 1.
7. Return A.
```

同样的，根据上面的英文，我们将其转换为可理解的代码，如下所示。

![](_attachment/img/Array.prototype.map)

有了上面实现 push 和 pop 的基础思路，map 的实现也不会太难了，基本就是再多加一些判断，循环遍历实现 map 的思路，将处理过后的 mappedValue 赋给一个新定义的数组 A，最后返回这个新数组 A，并不改变原数组的值。

## reduce 方法的底层实现

ECMA 官网关于 reduce 的基本描述（链接：[ECMA 数组的 reduce 标准](https://tc39.es/ecma262/#sec-array.prototype.reduce)），如下所示。

```plain
When the reduce method is called with one or two arguments, the following steps are taken:
1. Let O be ? ToObject(this value).
2. Let len be ? LengthOfArrayLike(O).
3. If IsCallable(callbackfn) is false, throw a TypeError exception.
4. If len = 0 and initialValue is not present, throw a TypeError exception.
5. Let k be 0.
6. Let accumulator be undefined.
7. If initialValue is present, then
    Set accumulator to initialValue.
8. Else,
    Let kPresent be false.
    Repeat, while kPresent is false and k < len,
        Let Pk be ! ToString(F(k)).
        Set kPresent to ? HasProperty(O, Pk).
        If kPresent is true, then
        Set accumulator to ? Get(O, Pk).
        Set k to k + 1.
    If kPresent is false, throw a TypeError exception.
9. Repeat, while k < len,
    Let Pk be ! ToString(F(k)).
    Let kPresent be ? HasProperty(O, Pk).
    If kPresent is true, then
        Let kValue be ? Get(O, Pk).
        Set accumulator to ? Call(callbackfn, undefined, « accumulator, kValue, F(k), O »).
    Set k to k + 1.
10. Return accumulator.
```

还是将其转换为我们自己的代码，如下所示。

![](_attachment/img/Array.prototype.reduce)

根据上面的代码及注释，有几个关键点你需要重点关注：

1. 初始值默认值不传的特殊处理；
2. 累加器以及 callbackfn 的处理逻辑。

## 部分实现源码

- pop：[V8 源码 pop 的实现](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L394)
- push：[V8 源码 push 的实现](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L414)
- map：[V8 源码 map 的实现](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L1036)
- slice：[V8 源码 slice 的实现](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L586)
- filter：[V8 源码 filter 的实现](https://github.com/v8/v8/blob/98d735069d0937f367852ed968a33210ceb527c2/src/js/array.js#L1024)
