---
aliases: []
tags: ['JavaScript/functional_programming', 'date/2023-02', 'year/2023', 'month/02']
date: 2023-02-21-星期二 11:31:03
update: 2023-02-21-星期二 16:11:31
---

也许你曾经在 Redux 的官方文档中，读到过这样的描述：“reducer 必须是一个 **纯函数**”。

也许你曾经在某一次面试中，遇到过这样的问题：“如何理解 **纯函数** 的优势”？

也许你曾经在某篇社区热门文章中，读到过这样的描述：“xxx 会引入 **副作用**，这样做不够优雅”。

随着函数式编程思想在前端领域逐渐崭露头角，纯函数这个概念也越来越多地受到前端社区的关注。

在过去，它对你来说可能是一套 Redux 的编写规则，也可能是一道稍显晦涩的问答题。

但现在，你需要知道，**纯函数是函数式编程的一个最大的前提，也是这坨知识体系的根基**。

为了打好这个根基，我们将深入探讨如下问题：

- 纯函数、副作用的内涵
- 纯函数/非纯函数的辨析
- 从数据流的角度理解“纯”与“不纯”的本质
- 纯函数解决了什么问题

大家不妨把这几个问题先记下来，作为自己构建知识体系的线索，也作为后续检验自己学习成果的标准。

在本节的开始，我们首先要来探讨“**是什么**”的问题。

## 厘清两个概念

### 什么是纯函数？

同时满足以下两个特征的函数，我们就认为是纯函数：

- 对于相同的输入，总是会得到相同的输出
- 在执行过程中没有语义上可观察的副作用。

### 什么是副作用？

我们看到，在纯函数的定义中，出现了对”副作用“的描述。

相比于“函数副作用”来说，更为大家所熟知的一个概念或许是“药物副作用”：我们为了治疗 A 疾病服用某种药物，药物在缓解 A 疾病的症状之余，可能会导致 B 疾病。那么“引发 B 疾病”就是这个药物的副作用。

生活经验告诉我们， 药物副作用的产生是由“**药物的影响面过大**”导致的。

比如我们原本只是期望药物帮助我们消除呼吸系统的炎症，但这种药物的作用范围并不仅限于你的呼吸系统，它还会刺激你的肠胃、导致肠胃功能紊乱。

原本我们只希望它伸出一只手来解决呼吸系统的问题，但现在它却 **伸出了两只手，一只手帮你解决问题，另一只手创造更多的问题**（如下图）：

![[_attachment/img/41451b1b9ec108d5858abf14032a9ac4_MD5.png]]

从图中我们可以看出，副作用指的正是药物在完成正常工作任务（作用于呼吸系统）之外，对外部环境（消化系统）所施加的影响。

我们对这句话稍作修改，便能够得到函数副作用的定义：

> 在计算机科学中，**函数副作用** 指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。 ——[维基百科](<https://zh.wikipedia.org/zh-hans/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>)

简单地讲：对函数来说，它的正常工作任务就是【**计算**】，除了计算之外，它不应该搞别的。

**如果一个函数除了计算之外，还对它的执行上下文、执行宿主等外部环境造成了一些其它的影响，那么这些影响就是所谓的”副作用”。**

干嚼理论太空洞，接下来我们就趁热打铁，借助几个具体的编码案例，一起来认识一下纯函数的真面目。

## 举几个 🌰 来辨析一下

### Case 1：加法函数

先来看一个 add 函数：

```js
let a = 10
let b = 20
function add() {
  return a + b
}
```

这个函数是不是纯函数？

答案是否定的，因为对于相同的输入，它无法做到相同的输出。

比如我们初次执行 add() 时，它会 return 一个 30 出来。

但如果我在全局作用域做了如下修改：

```js
a = 30
b = 40
```

此时再次调用 `add()`，我们得到的输出就将从 30 变为 70。

对于相同的输入，`add()` 函数给到了不同的输出。这违背了纯函数的第一条规则：**对于相同的输入，总是会得到相同的输出**。

有同学可能产生这样的疑问：楼上好像是两次截然不同的输入啊？第一次输入了 `a=10,b=20`；第二次又改为了 `a=30,b=40`。

这里需要强调的是，“输入”指的是 **函数的入参**。

对于 `add()` 函数来说，它的输入其实是一直都是 void。

那么我们怎么处理才能够使 add 函数变为一个纯函数呢？

方法也很简单，只需要把“数据的输入”这件事情完全交给入参来做就可以了，我们可以这样改造：

```js
let a = 10
let b = 20

function add(a, b) {
  return a + b
}

// 30
add(a, b)

a = 30
b = 40

// 70
add(a, b)
```

简单的改造后，add 函数就能够充分满足纯函数的两个条件了：

1. 对于相同的输入，总是会得到相同的输出：对于相同的 `a` 和 `b` 来说，它们的和总是相等的 ✅
1. 在执行过程中没有语义上可观察的副作用：`add()` 函数除了加法计算之外没有做任何事，不会对外部世界造成额外影响 ✅

### Case 2：姓名处理函数

接下来我们来看一个姓名处理函数：

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`
  console.log(`I am ${fullName}`)
  return fullName
}

processName('约瑟翰', '庞麦郎')
```

这个函数也是一个不纯的函数，问题出在这行 `console.log()` 上。

`console.log() ` 会在控制台打印一行文字，这改变了浏览器的控制台，属于对外部世界的影响，也就是说 **processName 函数在执行过程中产生了副作用**。

要想把它改回纯函数也非常简单，只需要像这样把副作用摘出去就可以了：

```js
function processName(firstName, secondName) {
  const fullName = `${firstName}·${secondName}`
  return fullName
}

console.log(processName('约瑟翰', '庞麦郎'))
```

### Case 3：网络请求函数

最后我们再来看一个非常经典的 Case：

```js
function getData(url) {
  const response = await fetch(url)
  const { data } = response
  return data
}
```

`getData` 函数是否是一个纯函数？

答案是否定的，**一个引入了网络请求的函数，从原则上来说是纯不起来的**。

为什么网络请求会使函数变得不纯呢？我们以示例代码中的 get 请求为例来分析一下：

- 请求获取到的 `response` 是动态的：需要通过网络请求获取的数据往往是动态的，**对于相同的输入，服务端未必能够给到相同的输出**。
- 请求可能出错：既然是网络请求，那就一定要考虑失败率的问题。网络拥塞、机房起火、后端删库跑路等等问题都有可能导致请求过程中的 `Error`，**未经捕获的 `Error` 本身就是一种副作用**。

当请求方法为 `post`、`delete` 等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数的“不纯”更进一步。

## “纯”与“不纯”的本质

通过对以上示例的分析，我们已经能够借助两大特征来快速地对函数的“纯”与“不纯”进行甄别。

### “纯”的本质——有且仅有【显式数据流】

站在特征的肩膀上，我们再去理解纯函数的学术定义，就会简单得多：

> 纯函数（Pure Function）——输入输出数据流全是 **显式**（Explicit）的函数。 —— 维基百科

定义中的“显式”这个概念，其实非常好理解，它约束的是数据的来源（**入参**）和出口（**返回值**）。

数据以入参形式传入，这叫【显式输入数据流】。

数据以返回值形式输出，这叫【显式输出数据流】。

定义中要求“输入输出数据流全是 **显式**（Explicit）的”，那就是说数据只能以入参的形式进来，并且只能以返回值的形式出去。

由此，我们可以把“学术定义”翻译为如下的大白话：

> 纯函数——**输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其它形式和外界进行数据交换的函数**。 ——修·格拉底·鲁迅·言思妥耶夫斯基

所以说，纯函数到底“纯”在哪里？

纯就纯在【**显式数据流**】！

那么，显式数据流是啥呢？

显式数据流意味着 **函数除了入参和返回值之外，不以任何其它形式与外界进行数据交换**。

反复把这句话说三遍，然后我们带着这个结论重新分析一遍楼上的 3 个案例。

### “不纯”的元凶——隐式数据流

对于 **Case 1** 中的加法函数来说，它的不纯是由 **隐式的数据输入** 导致的——我们通过观察 `add()` 函数的入参声明，并不能够发觉 a 和 b 两个数据源的存在。

`a` 和 `b` 两个变量并没有以入参的形式传入，而是在函数执行过程中直接被从全局作用域“抓进来”参与计算的（如下图），这就是典型的隐式数据交换。

![[_attachment/img/630069b3cb9e0b786d4bd34bb604f677_MD5.png]]

图中的横向数据流表示函数自身的显式数据流动，方向是从入参到出参。

纵向数据流则是隐式数据流，代表函数和外界的数据交换。

**一个纯函数在执行过程中应该只有横向数据流，而不应该有纵向数据流。**

对于 **Case 2** 中的姓名处理函数来说，它的不纯则是由 **隐式的数据输出** 导致的。

我们通过观察 `processName()` 的 return 语句，只能够观察到“`fullName`”这个变量的输出。

但在实际的执行中，`processName()` 会偷偷地向控制台输出一行字符串，这个字符串脱离了显式数据流的流向，进而导致函数不纯（如下图）：

![[_attachment/img/f577cb160ea97cb5ffcb2943ce71efda_MD5.png]]

**Case 3** 中的网络请求函数，同样是与外界进行了隐式的数据交换，导致出现了显式和隐式的两条交叉的数据流。

## 函数为何非“纯”不可？

这我们就要从函数式编程的数学背景说起了。

若我们试着对“函数式编程”思想追根溯源，会发现它最早正是从数学理论中推导出来的。

> 其中一个最关键的理论叫做“范畴论”，它也是本册的一个重点，我把它放在 [第 17 节](https://juejin.cn/book/7173591403639865377/section/7175422979646423098) - [21](https://juejin.cn/book/7173591403639865377/section/7175421412075634725) 节进行讲解。

- [ ] 1
      数学家的工作和计算机工程师的工作其实是很相似的。数学家们同样需要处理大量的抽象、以及抽象与抽象之间的关系。

而数学和计算机科学的发展，总是相互影响、相互成就的。

在漫长的相互影响的过程中，它们之间重叠出了许多有趣的交集，其中一个关键的交集，就是“函数”。

## 非“纯“不可的数学背景

### 数学世界的函数 VS 程序世界的函数

众所周知，数学中的函数，和计算机语言中的函数之间，并不能简单地画上等号。

数学中的函数总是遵循着这样的原则：**同一个输入，同一个输出。**

不管是长这样的函数：

![[_attachment/img/588f7e8eed7b19b6a2b75155b2684c0e_MD5.png]]

还是长这样的函数：

![[_attachment/img/86441fd74625c4a281e2a654b9a1c11f_MD5.png]]

抑或是长这样的函数：

![[_attachment/img/60f75c9fdc701b1a89c9fa900fd01a64_MD5.png]]

**对于一个给定的自变量 x，总是会有且仅有一个因变量 y 与它对应。**

而计算机科学中的函数，相比之下要灵活的多。

以 JS 为例，如下的函数在 JS 看来是极度正常的：

```js
let a = 1

function add(x) {
  return a + x
}

// 输出 3
add(2)

a = 10

// 输出 12
add(2)
```

对于 add 函数来说，给定一个指定的自变量 `x = 1`，JS 并不能给你保证 `add(x)` 每次的输出都是一致的。

再看一个获取当天日期的函数：

```js
function getToday() {
  return new Date().getDate()
}
```

今天是 22 号，我调用 `getToday()`，它自然会返回 22 给我。

如果我明天、后天、大后天再来分别调用一次 `getToday()`，尽管输入都是 `void`，但输出却分别是 23、24、25。

如果人在洛杉矶、刚下飞机的同事赵二狗在他的电脑上运行了这个函数，那么由于时区不同，即便我们都在同一个时刻执行 `getToday()`，两台电脑的输出也是截然不同的。

由此我们可以看出，能够影响 JS 函数输出的因素太多了，函数入参只是众多因素中的一个。

执行上下文中某个外部变量的变化、函数执行宿主的变化、系统时区的变化……甚至空气中温度、湿度的变化（JS 是可以调用传感器 API 的），都会影响 JS 函数的输出。

程序相对于数学来说，是个实实在在的“花花世界”。

JS 允许函数读写外部变量，允许函数引入副作用。这强化了程序的能力，却弱化了程序的数学性。

### 数学化的 JS 函数 === 纯函数

既然函数式编程起源于数学，那要想实践函数式编程，咱的函数自然得先能表现出一种“**类似数学**”的行为。

“类似数学”的函数行为是什么样的？就如我们上文所说的，对于一个给定的的输入，它总是给到你相同的输出。

说白了，就是 **函数除了纯纯的计算，啥也不干**。

而这，恰恰就是我们对纯函数的预期。

“纯函数”本质上是一套规则，是一种约束。

这层约束存在的背景，就是为了让 JS 函数和数学函数的行为对齐。

在这个基础上，JS 语言就可以站在“巨人”的肩膀上，充分汲取数学世界的养分了。

## 非“纯”不可的现实意义

如果你打开搜索引擎，检索“纯函数的好处/优势”，然后将所能够检索到结果一一罗列，你会发现这东西的好处似乎有巨大的一箩筐，仿佛它能解决所有的问题——难道纯函数就是传说中的“银弹”吗？

答案当然是否定的。

社区对纯函数优势的见解存在多样性，更多是因为人们看待它的视角不同。

从不同的视角出发，我们确实会发现纯函数能够解决不少具体的小问题。

而它之所以能够解决这些小问题，归根结底还是因为它解决了两个大问题，那就是“**不确定性**”和“**副作用**”。

### 纯函数，高度确定的函数

不纯的函数（Impure function）最直接的问题，就是不确定性——Impure function 的行为是难以预测的；对于同样的输入，Impure function 不能够保证同样的输出。

以测试过程为例：单元测试的主要判断的依据就是函数的输入和输出。如果对于同样的输入，函数不能够给到确定的输出，测试的难度将会陡然上升。

不确定性也会导致我们的代码难以被调试、数据变化难以被追溯、计算结果难以被复用等等。

总而言之一句话：不确定性意味着风险，而风险是万恶之源。

### 纯函数，没有副作用的函数

消除副作用，足以解决函数中大多数的不确定性。

此外，副作用的消除还解决了并行计算带来的竞争问题。

因为不纯的函数有可能访问同一块资源，进而相互影响，引发意想不到的混乱结果。

试想这样一种场景，A 函数和 B 函数都需要向某个文件写入信息，一旦我们先后调用了 A、B 两个函数，就将触发两个并行的写入过程，进入混乱的竞争态。

而纯函数则不存在这种问题，纯函数的计算完全发生在函数的内部，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。

### 纯函数，更加灵活的函数

无论是引入了外部变量的 `add()` 函数，还是依赖了 JS 内置对象的 `getToday()` 函数，它们的执行都严重地依赖了函数的运行环境。

更确切地说，这些函数是被 **困在了特定的上下文** 里。

假如我们将 `add()` 函数导出到一个没有 `a` 变量，或者 `a` 变量类型不为数字的上下文里，那么这个函数将当场失控。

同理，假如我想调用 `getToday()` 函数，那我必须先确认当前上下文里的 `Date` 类没有被篡改过。

（当然啦，正常的业务开发里，侵入式地篡改 JS 内置 Class 是非常罕见、也极不推荐大家做的事情）。

这里我想要强调的是，这些不纯的函数是不灵活的。

它们只能在某一个特定的上下文里运行，一旦脱离了这个上下文，就会失去预期中的效用。

纯函数则完全不存在这个弊端，因为它太简单了，它除了入参谁也不认，除了计算啥也不干。

因此，**纯函数是高度灵活的函数，它的计算逻辑在任何上下文里都是成立的。**

### 纯函数可以改善代码质量

从研发效率上来看，纯函数的实践，实际上是将程序的“外部影响”和“内部计算”解耦了。

这间接地促成了程序逻辑的分层，将会使得模块的功能更加内聚。

作为程序员，我们在开发的过程中，不再需要去关注函数可能会造成的外部影响，只需要关注函数本身的运算逻辑。

这和 [[设计模式之道#SOLID 设计原则|《设计模式》]] 中提及的“单一职责”原则有异曲同工之妙——设计模式中，我们强调将“**变与不变**”分离，而纯函数强调将 **计算与副作用** 分离。

计算是确定性的行为，而副作用则充满了不确定性。这一实践，本质上也是在贯彻“变与不变分离”的设计原则。

这样的逻辑分层将会使得我们的程序更加健壮和灵活，也会促成更加专注、高效的协作。

## 副作用不是毒药

对于纯函数来说，副作用无疑是地雷、是毒药。

但对于一个完整的程序来说，副作用却至关重要。

函数生产的是数据，这些数据要想作用于外部世界、创造一些真正的改变，就必须借助副作用。

试想，公司为什么要花钱雇程序员？

因为要做网页，这需要程序员操作 DOM；因为要 CRUD，这需要程序员操作 DB；因为要读写文件，这需要程序员执行 IO…… 如果我们试图把一个业务程序员的简历用一句话概括，那无外乎“精通实现各种副作用”。

老板和客户不会关心你的代码是否优雅，只会关心那些肉眼可见的副作用——页面渲染、网络请求、数据读写等等是否符合预期。

**会关注代码本身的，有且仅有我们程序员自己。**

对于我们程序员来说，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。
