---
aliases: []
tags: ['Network','date/2022-03','year/2022','month/03']
date: 2022-03-06-星期日 12:16:31
update: 2022-09-06-星期二 16:35:58
---

## 缓存位置

从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
- 网络请求

### Service Worker

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们 **自由控制** 缓存哪些文件、如何匹配缓存、如何读取缓存，并且 **缓存是持续性的**。

当 Service Worker 没有命中缓存的时候，我们需要去调用 `fetch` 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。**但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。**

### Memory Cache

Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**

在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

### Push CachePush Cache

Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。**

Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是日后的一个趋势。这里推荐阅读 [HTTP/2 push is tougher than I thought 这篇文章](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)

总结：

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 `no-cache` 和 `no-store` 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 你可以给其他域名推送资源

### 网络请求

如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

## HTTP 缓存

缓存常常被用作性能优化的技术方案之一，通过缓存我们可以有效地减少资源获取的耗时，减少用户的等待时长，从而提升用户的体验。

其中，我们可以通过 HTTP 协议，设置浏览器对 HTTP 响应资源进行缓存。使用浏览器缓存后，当我们再发起 HTTP 请求时，如果浏览器缓存发现请求的资源已经被存储，它会拦截请求并返回该资源的副本，不需要再去请求服务端获取资源，因此减少了 HTTP 请求的耗时，同时也能有效地缓解服务端压力。

一般来说，HTTP 缓存只能存储 GET 请求的响应内容，对于这些响应内容可能会存在两种情况：

1. 不缓存内容，每次请求的时候都会从服务端获取最新的内容；
2. 设置了缓存内容，则在有效期内会从缓存获取，如果用户刷新或内容过期则去服务端获取最新的内容。

那么，要如何给 GET 请求设置缓存呢？在浏览器中，便是依靠请求和响应中的头信息来控制缓存的。根据缓存的行为，我们可以将它们分为 **强制缓存** 和 **协商缓存** 两种，并且缓存策略都是通过设置 HTTP Header 来实现的。

### 强制缓存

 强制缓存， 在规定有效期内，直接使用缓存。可以通过以下的方式使用强制缓存：

1. 服务端通过设置 `Expires` 和 `Cache-Control`，和客户端约定缓存内容的有效时间；
2. 若符合缓存条件，浏览器响应 HTTP 200(from cache)。

举个例子，你的公司用版本号管理某个对外提供的 JS 文件。比如说 libgo.1.2.3.js，就是 libgo 的 1.2.3 版本。其中 1 是主版本，2 是副版本，3 是补丁编号。每次你们有任何改动，都会更新 libgo 版本号。在这种情况下，当浏览器请求了一次 libgo.1.2.3.js 文件之后，还需要再请求一次吗？

整理下我们的需求，浏览器在第一次进行了 `GET /libgo.1.2.3.js` 这个操作后，如果后续某个网页还用到了这个文件（libgo.1.2.3.js），我们不再发送第二次请求。这个方案要求浏览器将文件缓存到本地，并且设置这个文件的失效时间（或者永久有效）。这种请求过一次不需要再次发送请求的缓存模式，在 HTTP 协议中称为 **强制缓存**。当一个文件被强制缓存后，下一次请求会直接使用本地版本，而不会真的发出去。

**使用强制缓存时要注意，千万别把需要动态更新的数据强制缓存**。一个负面例子就是小明把获取用户信息数据的接口设置为强制缓存，导致用户更新了自己的信息后，一直要等到强制缓存失效才能看到这次更新。

#### Expires

`Expires` 是 HTTP/1 的产物，表示该资源的过期时间，是一个 GMT 格式的标准时间。

当客户端请求服务器的时候，服务器会返回资源的同时还会带上响应头 Expires，表示资源的过期具体时间，如果客户端在过期时间之前再次获取该资源，就不需要再请求我服务器了，可以直接在缓存里面拿。

使用 Expires 强缓存优点：

- 在过期时间以内，为用户省了很多流量。
- 减少了服务器重复读取磁盘文件的压力。

使用 Expires 强缓存缺点：

- 缓存过期以后，服务器不管文件有没有变化会再次请求服务器。
- 缓存过期时间是一个具体的时间，这个时间依赖于客户端的时间，如果时间不准确或者被改动缓存也会随之受到影响。

#### Cache-control

`Cache-Control` 出现于 HTTP/1.1，**优先级高于** `Expires` 。

`Cache-Control` 可以在 **请求头或者响应头** 中设置，并且可以组合使用多种指令

![[TIM图片20200617182100.png]]

从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。

`Cache-Control` 服务端参数：

- `max-age=30`：在 30 秒内有效，是一个相对时间，这样比 Expires 具体的时间就更精确了。当为 0 的时候就是不使用强缓存，类似 no-cache。
- `s-maxage`：就是用于表示 cache 服务器上（比如 cache CDN，缓存代理服务器）的缓存的有效时间的，覆盖 max-age，并只对 public 缓存有效。
- `no-cache`：不使用本地强缓存。资源被缓存，但是立即失效，下次会发起请求验证资源是否过期使用缓存协商。
- `no-store`：不缓存任何响应 ，直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
- `public`：可以被所有的用户缓存，包括终端用户和中间代理服务器。
- `private`：只能被终端用户的浏览器缓存，不允许中间缓存代理进行缓存。（这个是默认值）

^15680a

`Cache-Control` 客户端参数：

- `max-stale=5`： 表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在 5 秒之内，还是可以从代理中获取的。
- `min-fresh=5`： 表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。
- `only-if-cached`： 这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回 504（Gateway Timeout）。

### 协商缓存

说一个场景：小明开发了一个接口，这个接口提供全国省市区的 3 级信息。先问你一个问题，这个场景可以用强制缓存吗？小明一开始觉得强制缓存可以，然后突然有一天接到运营的通知，某市下属的两个县合并了，需要调整接口数据。小明错手不急，更新了接口数据，但是数据要等到强制缓存失效。

为了应对这种场景，HTTP 协议还设计了 **协商缓存**。协商缓存启用后，第一次获取接口数据，会将数据缓存到本地，并存储下数据的摘要。第二次请求时，浏览器检查到本地有缓存，将摘要发送给服务端。服务端会检查服务端数据的摘要和浏览器发送来的是否一致。如果不一致，说明服务端数据发生了更新，服务端会回传全部数据。如果一致，说明数据没有更新，服务端不需要回传数据。

从这个角度看，协商缓存的方式节省了流量。对于小明开发的这个接口，多数情况下协商缓存会生效。当小明更新了数据后，协商缓存失效，客户端数据可以马上更新。**和强制缓存相比，协商缓存的代价是需要多发一次请求。**

协商缓存， 与服务端协商是否使用缓存。可以通过以下的方式使用协商缓存：

1. 协商缓存主要有四个头字段，它们两两组合配合使用，`If-Modified-Since` 和 `Last-Modified` 一组，`Etag` 和 `If-None-Match` 一组
2. 服务端通过设置 `If-None-Match` 和 `If-Modified-Since`，和客户端约定标识协商缓存的值；
3. 当有效期过后，浏览器将缓存信息中的 `Etag` 和 `Last-Modified` 信息，分别使用 `If-None-Match` 和 `If-Modified-Since` 请求头设置，提交给服务端。当同时存在的时候会以 `Etag` 和 `If-None-Match` 为主。
4. 当命中协商缓存的时候，服务端则响应 HTTP 304，浏览器将从缓存读数据。

![[TIM图片20200617223438.png]]

若以上缓存条件均不符合，服务端响应 HTTP 200，返回更新后的数据，同时通过响应头更新 HTTP 缓存设置。整个过程可以用下面的流程图来表示：

![[CioPOWCCZ3WAFH_BAAF-GPWG-Gs412.png]]

浏览器会在第一次请求完服务端后得到响应，通过适当地设置响应头信息，我们可以使用更多的缓存资源，从而提升网站的响应速度和性能，给到用户更好的体验。

#### Last-Modified 和 If-Modified-Since

`Last-Modified`：响应头，资源最近修改时间，由服务器告诉浏览器。

`If-Modified-Since`：请求头，资源最近修改时间，由浏览器告诉服务器。其实就是第一次访问服务端返回的 `Last-Modified` 的值。

当客户端第一次请求服务器的时候，服务端会返回一个 `Last-Modified` 响应头，该字段是一个标准时间。客户端请求服务器的时候会带上 `If-Modified-Since` 请求头字段，该字段的值就是服务器返回的 `Last-Modified` 的值。服务器接收到请求后会比较这两个值是否一样，一样就返回 304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新 `Last-Modified` 响应头字段的值。

但是 `Last-Modified` 存在一些弊端：

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 `Last-Modified` 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 `Last-Modified` 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

因为以上这些弊端，所以在 HTTP / 1.1 出现了 `ETag` 。

#### ETag 和 If-None-Match

为了解决文件修改时间只能精确到秒带来的问题，HTTP / 1.1 引入 Etag 响应头。Etag 是由文件修改时间与文件大小计算而成，类似于文件指纹，只有当文件文件内容或修改时间变了 `Etag` 的值才会发生变化。

当客户端第一次请求服务器的时候，服务端会返回一个 `Etag` 响应头。客户端请求服务器的时候会带上 `If-None-Match` 请求头字段，该字段的值就是服务器返回的 `Etag` 的值。服务器接收到请求后会比较这两个值是否一样，一样就返回 304，让客户端从缓存中读取，不一样就会返回新文件给客户端并更新 `Etag` 响应头字段的值。并且 `ETag` 优先级比 `Last-Modified` 高。

那么如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 `Last-Modified` 值的 10% 作为缓存时间。
