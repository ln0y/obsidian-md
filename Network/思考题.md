---
aliases: []
tags: ['Network', 'date/2022-04', 'year/2022', 'month/04']
date: 2022-04-17-Sunday 15:56:06
update: 2022-04-17-Sunday 16:02:50
---

## 一台内存在 8G 左右的服务器，可以同时维护多少个连接？

【**解析**】连接是内存中的状态对象，从理论上分析，连接本身不太占用内存。不同语言连接对象大小不等，但是通常很小。下面提供一段 Java 程序，你可以感受一下：

```java
public class Server {
public static void main(String[] argv) throws IOException {
var serverSocket = new ServerSocket();
var addr = new InetSocketAddress(3001);
        serverSocket.bind(addr);
var list = new LinkedList<>();
while(true) {
var client = serverSocket.accept();
            list.add(client);
            System.out.println(list.size());
        }
    }
}
public class Client {
public static void main(String[] argv) throws IOException, InterruptedException {
var clients = new LinkedList<>();
for(int i = 0; i < 1000000; i++) {
var client = new Socket("127.0.0.1", 3001);
            clients.add(client);
        }
        Thread.sleep(10000000);
    }
}
```

通过运行上面这段程序，你可以观察到以下这几个现象：

1. 创建 100W 连接速度不是很快，**这说明 TCP 连接创建有成本**（3 次握手，都是网络 IO）；
2. 用`jps`找到对应的进程的`id`，在用`sudo cat /proc/{进程ID}/status | grep VmHWM`可以看到实际的内存占用。按照这种增长趋势，8G 内存空间可以轻轻松松存放 100W 个连接。

但是如果单机建立太多的连接，会报一个`Cannot assign requested address`的异常，这是因为客户端连接服务端时，操作系统要为每个客户端分配一个端口，上面的程序很快会把端口号用尽。

所以，我们可以得出一个结论：**核心的问题是，通信需要缓冲区，通信需要 I/O。这是因为通信占用资源，连接本身占用资源少**。

## 有哪些好用的压测工具？

压力测试最常见的工具是 Apache Benchmark（简称 AB），在 Linux 下面可以通过包管理器安装 ab：

```shell
yum install httpd-tools
// 或
apt-get install apache2-utils
```

ab 安装好后，可以利用下面这条指令向某个网站发送并发 1000 的 10000 次请求：

```shell
ab -n 10000 -p 1000 https://example.com/
```

ab 是用 C 语言写的，作为一个随手就可以用的工具，它的设计非常简单，是一个单线程的工作模型，因此如果遇到阻塞情况，可能直接导致 ab 工具自己积压崩溃。

所以。这里我给你推荐一个 Java 生态好用的工具“JMeter”，拥有可视化的界面。

这个工具在各个平台上都可以用，比 ab 稳定，有图形化界面，可以配置任意线程数量，还有可视化的图表支持。

## 既然发送方有窗口，那么接收方也需要有窗口吗？

【**解析**】我们一起思考下，接收方收到发送方的每个数据分组（或者称为 TCP Segment），接收方肯定需要缓存。举例来说，如果发送方发送了：1, 2, 3, 4。 那么接收方可能收到的一种情况是：1，4，3。注意，没有收到 2 的原因可能是延迟、丢包等。这个时候，接收方有两种选择。

**选择一：什么都不做**（这样分组 2 的 ACK 就不会发送给发送方，发送方发现没有收到 2 的 ACK，过一段时间就有可能重发 2,3,4,5）。 当然具体设计还需要探讨，比如不重发整个分组，只重发已发送没有收到 ACK 的分组。

这种方法的缺陷是**性能太差**，重发了整个分组（或部分）。因此我们可以考虑另一种选择。

**选择二**：如果**重发一个窗口，或部分窗口**，问题就不会太大了。虽然增加了网络开销，但是毕竟有进步（1 进步了，不会再重发）。

性能方面最大的开销是**等待超时的时间**，就是发送方要等到超时时间才重发窗口，这样操作性能太差。因此，TCP 协议有一个**快速重传**的机制——接收方发现接收到了 1，但是没有接收到 2，那么马上发送 3 个分组 2 的 ACK 给到发送方，这样发送方收到多个 ACK，就知道接收方没有收到 2，于是马上重发 2。

无论是上面哪种方案，接收方也维护一个滑动窗口，是一个不错的选择。接收窗口的状态，可以和发送窗口的状态相互对应了。

## Moba 类游戏的网络应该用 TCP 还是 UDP？

【**解析**】所有在线联机游戏都有件非常重要的事情需要完成，就是**确定事件发生的唯一性**，这个性质和聊天工具是类似的。听我这么说，是不是有点迷？请听我慢慢道来。

你在王者荣耀中控制后羿释放技能，这是一个事件。同时，王昭君放了大招，这是第二个事件。两个事件一定要有先后顺序吗？答案是当然要有。因为游戏在同一时刻只能有一个状态。

类比一下，多个线程同时操作内存，发生了竞争条件，那么是不是意味着，内存在同一时刻有两个状态呢？当然不是，**内存同时刻只能有一个状态，所以多个线程的操作必须有先有后**。

回到 Moba 游戏的问题，每个事件，游戏服务器必须给一个唯一的时序编号，对应后羿的技能和王昭君的技能。所以，在线竞技类游戏，事实上是玩家在不断向服务器竞争一个自增序列号的过程。无论客户端发生怎样的行为，只有竞争到自增 ID 才能进步。也就是说，**服务器要尽快响应多个客户端提交的事件，并以最快的速度分配自增序号，然后返回给客户端**。

**所以，Moba 服务端的核心是自增序号的计算和尽量缩减延迟**。从这个角度出发，你再来看看，应该用 TCP 协议还是 UDP 协议呢？

虽然 TCP 协议有 3 次握手，但是连接上之后，双方就不会再有额外的传输成本，因此创建连接的成本，可以忽略不计。

同时，TCP 协议还提供稳定性支持，不需要自己实现稳定性。如果规模较小的在线竞技类游戏，TCP 完全适用。但是当游戏玩家体量上升后，TCP 协议的头部（数据封包）较大，会增加服务器额外的 I/O 压力。要发送更多的数据，自然有更大的 I/O 压力。从这个角度来看，UDP 就有了用武之地。

## 下面这几个地址 127.0.0.1, localhost, 0.0.0.0 有什么不同？

【**解析**】`127.0.0.1`是本地回环地址（loopback），发送到 loopback 的数据会被转发到本地应用。

localhost 指代的是本地计算机，用于访问绑定在 loopback 上的服务。localhost 是一个主机名，不仅仅可以指向 IPv4 的本地回环地址，也可以指向 IPv6 的本地回环地址 \[: :1\]。

`0.0.0.0`是一个特殊目的 IP 地址，称作不可路由 IP 地址，它的用途会被特殊规定。通常情况下，当我们把一个服务绑定到`0.0.0.0`，相当于把服务绑定到任意的 IP 地址。比如一台服务器上有多个网卡，不同网卡连接不同的网络，如果服务绑定到 0.0.0.0 就可以保证服务在多个 IP 地址上都可以用。

## 请你总结下 IPv6 和 IPv4 究竟有哪些区别？

【**解析**】I**Pv6 和 IPv4 最核心的区别是地址空间大小不同**。IPv6 用 128 位地址，解决了 IP 地址耗尽问题。因为地址空间大小不同，它们对地址的定义，对路由寻址策略都有显著的差异。

**在路由寻址策略上**，IPv6 消除了设备间地址冲突的问题，改变了划分子网的方式。在 IPv4 网络中，一个局域网往往会共享一个公网 IP，因此需要 NAT 协议和外网连接。

**在划分子网的时候**，IPv4 地址少，需要子网掩码来处理划分子网。IPv6 有充足的地址，因此不需要局域网共享外网 IP。也正因为 IPv6 地址多，可以直接将 IPv6 地址划分成站点、子网、设备，每个段都有充足的 IP 地址。

因为 IPv6 支持的 IP 地址数量大大上升，一个子网可以有 248 个 IP 地址，这个子网可能是公司网络、家庭网络等。这样 IP 地址的分配方式也发生了变化，IPv4 网络中设备分配 IP 地址的方式是中心化的，由 DHCP（动态主机协议）为局域网中的设备分配 IP 地址。而在 IPv6 网络中，因为 IP 地址很少发生冲突，可以由设备自己申请自己的 IP 地址。

另外因为 IPv6 中任何一个节点都可以是一个组播节点，这样就可以构造一个对等的网络，也就是可以支持在没有中心化的路由器，或者一个网络多个路由器的情况下工作。节点可以通过向周围节点类似打探消息的方式，发现更多的节点。这是一个配套 IPv6 的能力，叫作邻居发现（ND）。

## IPv6 协议还需要 NAT 吗？

【**解析**】IPv6 解决了 IP 耗尽的问题，为机构、组织、公司、家庭等网络提供了充足的 IP 资源，从这个角度看是不是就不需要 NAT 协议了呢？

在没有 IPv6 之前，NAT 是 IP 资源耗尽的主流解决方案。在一个内网中的全部设备通过 NAT 协议共享一个外网的 IPv4 地址，是目前内外网对接的主要方式。IPv6 地址资源充足，可以给全球每个设备一个独立的地址。从这个角度看 IPv6 的确不需要 NAT 协议。

但是目前的情况，是 IPv6 网络还没有完全普及。尽管很多公司已经支持自己的互联网产品可以使用 IPv6 访问，但是公司内部员工使用的内部网络还是 IPv4。如果要连接 IPv6 和 IPv4 网络，仍然需要 NAT 协议（NAT64），这个协议可以让多个 IPv6 的设备共享一个 IPv4 的公网地址。

## 请你用自己最熟悉的语言，写一个 UDP 连接程序，然后用 Wireshark 抓包。

【**解析**】关于这个问题，以 Java 为例，写了一个回声服务（即客户端发送什么服务段返回什么），以下是服务端程序：

```java
var socket = new DatagramSocket(8888);
var buf = new byte[256];
while (true) {
    DatagramPacket packet
            = new DatagramPacket(buf, buf.length);
    System.out.println("try receive...");
    socket.receive(packet);
var address = packet.getAddress();
int port = packet.getPort();
    packet = new DatagramPacket(buf, buf.length, address, port);
    String received
            = new String(packet.getData(), 0, packet.getLength());
    socket.send(packet);
}
```

以下是客户端程序：

```java
var buf = "Hello".getBytes();
var socket = new DatagramSocket();
var address = InetAddress.getByName("localhost");
var packet
          = new DatagramPacket(buf, buf.length, address, 8888);
  socket.send(packet);
  socket.receive(packet);
  String received = new String(
          packet.getData(), 0, packet.getLength());
  System.out.format("Server echo : %s\n", received);
```

通过观察上面两段程序，你会发现发送和接收的都是`Datagram`报文。而且服务端和客户端之间不需要建立连接。服务端可以通过读取客户端的地址区分客户端，客户端通过服务端地址和端口发送数据到服务端。

## 请你找一个 epoll 的 hello world 例子，并尝试理解它。

【**解析**】epoll 是一个 C 语言的 API，因此使用的时候需要一点 C 的基础。不过，即便没有，其实也不影响你读懂下面的程序。

下面是是一段摘自“[https://github.com/millken/c-example/blob/master/epoll-example.c](https://github.com/millken/c-example/blob/master/epoll-example.c?fileGuid=uCG9Y5F8xVkBmki5)”的示例程序，该程序用 epoll 模式实现了一个服务，如下所示：

```c
//https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/epoll.h>
#include <errno.h>

#define MAXEVENTS 64

static int
make_socket_non_blocking (int sfd)
{
  int flags, s;

  flags = fcntl (sfd, F_GETFL, 0);
  if (flags == -1)
    {
      perror ("fcntl");
      return -1;
    }

  flags |= O_NONBLOCK;
  s = fcntl (sfd, F_SETFL, flags);
  if (s == -1)
    {
      perror ("fcntl");
      return -1;
    }

  return 0;
}

static int
create_and_bind (char *port)
{
  struct addrinfo hints;
  struct addrinfo *result, *rp;
  int s, sfd;

  memset (&hints, 0, sizeof (struct addrinfo));
  hints.ai_family = AF_UNSPEC;     /* Return IPv4 and IPv6 choices */
  hints.ai_socktype = SOCK_STREAM; /* We want a TCP socket */
  hints.ai_flags = AI_PASSIVE;     /* All interfaces */

  s = getaddrinfo (NULL, port, &hints, &result);
  if (s != 0)
    {
      fprintf (stderr, "getaddrinfo: %s\n", gai_strerror (s));
      return -1;
    }

  for (rp = result; rp != NULL; rp = rp->ai_next)
    {
      sfd = socket (rp->ai_family, rp->ai_socktype, rp->ai_protocol);
      if (sfd == -1)
        continue;

      s = bind (sfd, rp->ai_addr, rp->ai_addrlen);
      if (s == 0)
        {
          /* We managed to bind successfully! */
          break;
        }

      close (sfd);
    }

  if (rp == NULL)
    {
      fprintf (stderr, "Could not bind\n");
      return -1;
    }

  freeaddrinfo (result);

  return sfd;
}

int
main (int argc, char *argv[])
{
  int sfd, s;
  int efd;
  struct epoll_event event;
  struct epoll_event *events;

  if (argc != 2)
    {
      fprintf (stderr, "Usage: %s [port]\n", argv[0]);
      exit (EXIT_FAILURE);
    }

  sfd = create_and_bind (argv[1]);
  if (sfd == -1)
    abort ();

  s = make_socket_non_blocking (sfd);
  if (s == -1)
    abort ();

  s = listen (sfd, SOMAXCONN);
  if (s == -1)
    {
      perror ("listen");
      abort ();
    }

  efd = epoll_create1 (0);
  if (efd == -1)
    {
      perror ("epoll_create");
      abort ();
    }

  event.data.fd = sfd;
  event.events = EPOLLIN | EPOLLET;
  s = epoll_ctl (efd, EPOLL_CTL_ADD, sfd, &event);
  if (s == -1)
    {
      perror ("epoll_ctl");
      abort ();
    }

  /* Buffer where events are returned */
  events = calloc (MAXEVENTS, sizeof event);

  /* The event loop */
  while (1)
    {
      int n, i;

      n = epoll_wait (efd, events, MAXEVENTS, -1);
      for (i = 0; i < n; i++)
	{
	  if ((events[i].events & EPOLLERR) ||
              (events[i].events & EPOLLHUP) ||
              (!(events[i].events & EPOLLIN)))
	    {
              /* An error has occured on this fd, or the socket is not
                 ready for reading (why were we notified then?) */
	      fprintf (stderr, "epoll error\n");
	      close (events[i].data.fd);
	      continue;
	    }

	  else if (sfd == events[i].data.fd)
	    {
              /* We have a notification on the listening socket, which
                 means one or more incoming connections. */
              while (1)
                {
                  struct sockaddr in_addr;
                  socklen_t in_len;
                  int infd;
                  char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];

                  in_len = sizeof in_addr;
                  infd = accept (sfd, &in_addr, &in_len);
                  if (infd == -1)
                    {
                      if ((errno == EAGAIN) ||
                          (errno == EWOULDBLOCK))
                        {
                          /* We have processed all incoming
                             connections. */
                          break;
                        }
                      else
                        {
                          perror ("accept");
                          break;
                        }
                    }

                  s = getnameinfo (&in_addr, in_len,
                                   hbuf, sizeof hbuf,
                                   sbuf, sizeof sbuf,
                                   NI_NUMERICHOST | NI_NUMERICSERV);
                  if (s == 0)
                    {
                      printf("Accepted connection on descriptor %d "
                             "(host=%s, port=%s)\n", infd, hbuf, sbuf);
                    }

                  /* Make the incoming socket non-blocking and add it to the
                     list of fds to monitor. */
                  s = make_socket_non_blocking (infd);
                  if (s == -1)
                    abort ();

                  event.data.fd = infd;
                  event.events = EPOLLIN | EPOLLET;
                  s = epoll_ctl (efd, EPOLL_CTL_ADD, infd, &event);
                  if (s == -1)
                    {
                      perror ("epoll_ctl");
                      abort ();
                    }
                }
              continue;
            }
          else
            {
              /* We have data on the fd waiting to be read. Read and
                 display it. We must read whatever data is available
                 completely, as we are running in edge-triggered mode
                 and won't get a notification again for the same
                 data. */
              int done = 0;

              while (1)
                {
                  ssize_t count;
                  char buf[512];

                  count = read (events[i].data.fd, buf, sizeof buf);
                  if (count == -1)
                    {
                      /* If errno == EAGAIN, that means we have read all
                         data. So go back to the main loop. */
                      if (errno != EAGAIN)
                        {
                          perror ("read");
                          done = 1;
                        }
                      break;
                    }
                  else if (count == 0)
                    {
                      /* End of file. The remote has closed the
                         connection. */
                      done = 1;
                      break;
                    }

                  /* Write the buffer to standard output */
                  s = write (1, buf, count);
                  if (s == -1)
                    {
                      perror ("write");
                      abort ();
                    }
                }

              if (done)
                {
                  printf ("Closed connection on descriptor %d\n",
                          events[i].data.fd);

                  /* Closing the descriptor will make epoll remove it
                     from the set of descriptors which are monitored. */
                  close (events[i].data.fd);
                }
            }
        }
    }

  free (events);
  close (sfd);
  return EXIT_SUCCESS;
}
```

接下来我给你分析下这段程序。下面这句在创建一个 epoll 实例，这个实例本质上也是一个文件，文件中是对`epoll`对象的调用序列。

```c
efd = epoll_create1 (0);
```

下面这段程序在注册线程关心的事件：

```c
struct epoll_event event;
event.data.fd = sfd;
event.events = EPOLLIN | EPOLLET;
s = epoll_ctl (efd, EPOLL_CTL_ADD, sfd, &event);
```

上面程序注册了两类关系的事件：

- EPOLLIN ，关联的文件发生的读取；
- EPOLLET， 关联的文件发生的写入。

接下来我们调用`epoll_wait`来获取发生的事件：

```c
n = epoll_wait (efd, events, MAXEVENTS, -1)
```

`n`是需要响应的事件数量。 因为在这之前用`make_socket_non_blocking`配置了非阻塞 IO，因此`epoll_wait`有可能返回 0，也就是没有消息。 对于`n>0`的情况，上面的示例程序中使用了 for 循环针对不同的消息类型进行处理。

下面这句`if`判断是在看如果 sfd（服务端 Socket 文件描述符）和发生事件的文件描述符一致，代表这是一次客户端的连接操作。

```c
if (sfd == events[i].data.fd)
```

于是再次调用`epoll_ctl`将这个客户端的读写事件注册到关注列表。

如果上面的`if`判断没有生效，说明这是一次客户端的读或写，这个时候使用`read`或`write`方法向客户端 Socket 文件中读取/写入数据。

## 在缓冲区的设计当中，还通常有一个 rewind 操作，这个操作是用来做什么的呢？

【**解析**】如果一个缓冲区是用来写入的，接下来要切换到读取状态可以使用 flip 操作。如果一个缓冲区进行了一次写和读，接下来要用它来处理另一批数据，可以使用 clear 操作来清空缓冲区。在实战当中，有时候一个缓冲区读取过了，需要再读取一次，此时就可以用 rewind 操作来重置缓冲区的 position 指针。

上面过程中 flip 和 rewind 都重置了 position 指针，那么它们的区别是什么呢？首先，你可以先从词义上理解下，flip 意味翻转（隐含读写状态切换），rewind 意味倒带（隐含重头读、重头写）。所以在实战中，首先我们应该从语义上区分它们的使用。

在实战的过程中，某些场景下 rewind 和 flip 结果相同。

比如现在缓冲区是 ABCDEFG，position=7, limit=7。这个时候代表我们已经完成了写入。如果需要切换到读取状态，用 flip 和 rewind 操作的结果相同，都会将 position 置零。

那么我提一个问题，这种情况下，应该用哪个呢？

写程序不只是为了正确，我们还为了可读。这种情况下，因为是读写状态的切换，因此当然用 flip。

再举个例子，比如现在缓冲区是 ABCDEFG，position=3，limit=7，缓冲区处于读取状态。如果我们想要重读，应该用什么呢？当然是 rewind，rewind 有倒带的语义。你可以思考，这个时候如果调 flip 结果对吗？

这个时候调 flip 处理会把 position 置为 0 外，limit 也会设置为 3（position 的旧值）。因为只有这样，才是读写状态的翻转。也就是说，如果写入了 3 个字符，不管 limit 现在是多少，flip 切换到读取状态也只能读 3 个字符。

所以，flip 和 rewind 实现不同是其次，最重要的是语义不同。建议你以后看到 API 的时候，先搞明白单词是什么意思，而不是急于分析具体实现。从这个话题引申出一个小的提示，就是不要盲目读源代码，在阅读一个项目的源代码前，思考下自己对要解决的问题、如何解决这些问题，带着这种根深的理解再去读源码。

## I/O 多路复用用协程和用线程的区别？

【**解析**】线程是执行程序的最小单位。I/O 多路复用时，会用单个线程处理大量的 I/O。还有一种执行程序的模型，叫协作程，协程是轻量级的线程。操作系统将执行资源分配给了线程，然后再调度线程运行。如果要实现协程，就要利用分配给线程的执行资源，在这之上再创建更小的执行单位。协程不归操作系统调度，协程共享线程的执行资源。

而 I/O 多路复用的意义，是减少线程间的切换成本。因此从设计上，只要是用单个线程处理大量 I/O 工作，线程和协程是一样的，并无区别。如果是单线程处理大量 I/O，使用协程也是依托协程对应线程执行能力。

## 如何理解 Dubbo 的几个组成部分 Consumer、Provider、Monitor 和 Registry？

【**解析**】Dubbo 是一个开源、轻量级的 Java 服务框架。下图是它的架构：

![[Cgp9HWCmZiyAUZIuAAEchcUDiyE739.png]]

Dubbo 的架构是容器化的，上 图中的 Container（容器）中是服务，服务的提供方被称作 Provider。比如要提供一个订单服务，那么服务会在容器中部署启动，启动后的实例就是 Provider。

Provider 在启动过程中，会在 Dubbo 中注册自己。负责注册和发现的模块，称为注册处（Registry）。注册处和学员报道时学校的注册处很像，每个新加入的服务都需要主动注册。这里需要注意，**注册处对网络中的信息是信任的，如果 Provider 被攻击欺骗注册处会产生安全问题。Registry 需要实现分布式共识，具体可以使用 ZooKeeper 实现（参考 Paxos 和 Raft 算法）**。

服务的使用方被称为 Consumer，Consumer 会订阅注册表的变化（也就是 Provider 的变化）。相当于 Consumer 本地维护了一份和注册处一致的 Provider 清单。当调用服务的时候，Consumer 会使用本地清单去查询 Provider 信息，进行远程调用。

除了 Registry、Consumer、Provider 之外，Dubbo 还有一个 Monitor 模块。这个模块负责统计服务器的调用情况。

## 如果你的应用需要智能 DNS 服务，你将如何实现？

【**解析**】首先你可以在你的域名解析系统中增加两条（或以上）ns 记录。比如说你的域名是 example.com，那么你可以增加 ns1.exmaple.com, ns2.example.com。当然，指定这两个域名的 IP 还需要配置两个 A 记录。

然后你需要两台机器（也可以是容器或者虚拟机），对应 ns1 和 ns2。最好用不在同一个物理机上的两个容器，这样可以避免一台物理机故障导致服务瘫痪。然后在每个容器（虚拟机）上安装一个 Named 服务。Named 是一个专门用来提供 DNS 服务的工具，在虚拟机上安装完成 Named 后，这个虚拟机就变成了一个权威服务器节点。

配置好 Named 后，你需要写几个脚本文件，给要提供 DNS 的域名配置信息。Named 配套使用的有个叫作 GeoDNS 的插件，可以提供基于地理位置的智能 DNS 服务。

更具体的操作，你可以参考这篇文档：[https://bind9.readthedocs.io/en/latest/configuration.html](https://bind9.readthedocs.io/en/latest/configuration.html?fileGuid=xxQTRXtVcqtHK6j8)。

## 写一张网页，用 WebRTC 实现点到点通信。

【**解析**】这里我为你找到了一份 Github 上的源代码：[https://github.com/ScaleDrone/webrtc/blob/master/](https://github.com/ScaleDrone/webrtc/blob/master/script.js?fileGuid=xxQTRXtVcqtHK6j8)。

![[Cgp9HWC4nISASrfFAAEwZ4EyOXU323.png|800]]

在 WebRTC 的网络世界中，视频传输可以走点到点服务。客户端被称作 Peer，Peer 的数据直接传送给另一个 Peer，我们也称作**P2P 网络**。在**P2P 网络中，要解决 NAT 穿墙问题，WebRTC 设计了一个网络的抽象框架被称作交互式网络建立连接（Interactive Connectivity Establishment， ICE）**，图中的 STUN 是 ICE 的一个实现。

对于一个 P2P 网络中的 Peer，它每次要接入这个 P2P 网络会获得一个身份，这个身份就包括它的 IP 地址、端口使用的协议等，这个身份被抽象成了一个对象——Candidate（候选人）。当候选人创建一个 P2P 连接的时候，它会获得候选人的身份。但这个时候，它还没有发起任何真实的数据连接。此时它必须知道另一个人的身份，才能够进行通信。

**P2P 网络本身不具备传输身份的能力，因此这个时候需要另一个第三方网络提供身份的交换**。代码中的这个第三方服务就是 ScaleDrone。当用户加入聊天室，会先创建连接：

```js
pc = new RTCPeerConnection(...)
```

接下来会触发`onicecanddiate`事件获得候选人（Candidate）身份：

```js
pc.onicecandidate = event => {
  if (event.candidate) {
    // 通过ScaleDrone分发身份
  }
}
```

在实际的代码操作中，代码将获得的身份（event.candiate）直接发送到了 ScaleDrone 提供的某个聊天室中去，这样聊天室的其他用户就会拿到这个身份。

当有新用户进入聊天室后，ScaleDrone 会广播新用户的身份：

```js
room.on('data', (message, client) => {
  // Message was sent by us
  if (client.id === drone.clientId) {
    return
  }
  if (message.sdp) {
    // This is called after receiving an offer or answer from another peer
    pc.setRemoteDescription(
      new RTCSessionDescription(message.sdp),
      () => {
        // When receiving an offer lets answer it
        if (pc.remoteDescription.type === 'offer') {
          pc.createAnswer().then(localDescCreated).catch(onError)
        }
      },
      onError
    )
  } else if (message.candidate) {
    // Add the new ICE candidate to our connections remote description
    pc.addIceCandidate(new RTCIceCandidate(message.candidate), onSuccess, onError)
  }
})
```

这个时候，用户彼此都会将对方加入自己的候选人列表：

```js
pc.addIceCandidate(new RTCIceCandidate(message.candidate), onSuccess, onError)
```

加入之后，如果远程候选人录制了视频，WebRTC 的 ontract 事件就会收到视频的数据流，也就是下面这段程序：

```js
pc.ontrack = event => {
  const stream = event.streams[0]
  if (!remoteVideo.srcObject || remoteVideo.srcObject.id !== stream.id) {
    remoteVideo.srcObject = stream
  }
}
```

这份代码的优势是不需要提供中转的流媒体服务器，就可以完成点到点的视频通信。同理，如果是多人视频，也可以用同样的方法实现。这段程序中需要两个第三方的服务：

1. 基于 ICE 标准提供 P2P 网络的服务（提供 NAT 穿透能力），这个可以使用 STUN；
2. 第三方聊天室服务，用于实现聊天的具体逻辑和交换身份。

## 自己写一个程序实测下对称加密和非对称加密的性能差距。

【**解答**】以下是用 Java 写的一段测试程序：

```java
package test;
import com.github.javafaker.Faker;
import org.junit.Test;
import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
public class RSA {
    @Test
    public void rsaEncode() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        var keyPairGen = KeyPairGenerator.getInstance("RSA");
        var pair = keyPairGen.generateKeyPair();
        var privateKey = pair.getPrivate().getEncoded();
        var faker = new Faker();
        var start = System.currentTimeMillis();
        var keyFactory = KeyFactory.getInstance("RSA");
        var keySpec = new PKCS8EncodedKeySpec(privateKey);
        var key = keyFactory.generatePrivate(keySpec);
        for(var i = 0; i < 10000; i++) {
            var randomBytes = faker.shakespeare().asYouLikeItQuote().getBytes();
            var cipher = Cipher.getInstance(keyFactory.getAlgorithm());
            cipher.init(Cipher.ENCRYPT_MODE, key);
            var resultBytes = cipher.doFinal(randomBytes);
            if(i % 100 == 0) {
                System.out.format("%d/10000 done.\n", i);
            }
        }
        System.out.format("time: %dms\n", System.currentTimeMillis() - start);
    }
    @Test
    public void aesEncode() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        var keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(128);
        var key = keyGenerator.generateKey();
        var faker = new Faker();
        var ivBytes = new byte[16];
        var start = System.currentTimeMillis();
        for(var i = 0; i < 10000; i++) {
            var randomBytes = faker.shakespeare().asYouLikeItQuote().getBytes();
            var cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            new SecureRandom().nextBytes(ivBytes);
            var iv = new IvParameterSpec(ivBytes);
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);
            var result = cipher.doFinal(randomBytes);
        }
        System.out.format("time: %dms\n", System.currentTimeMillis() - start);
    }
}
```

其中用 RSA 非对称加密算法加密 10000 个莎士比亚书中的句子，用时在 11s 左右，而采用 AES 对称加密算法加密，用时在 400ms 左右。

## 如果公司要求你生成一个公私钥对，然后去证书机构申请证书，请问如果你丢失了这个公私钥对有什么危害？你要如何保护这个公私钥对？

【**解答**】先明说说为什么会有这个问题。网站拥有者向 CA 机构申请证书时，证书请求文件中只包含公钥，不包含私钥。 证书私钥由网站保存，证书请求文件提交给 CA 机构进行认证和签名后对外公开。而大部分公司都会规定：含有敏感信息的数据不能带出公司，比如只能存放在公司的笔记本、公司的网盘、公司的服务器上，但是显然对于存储证书的场景不适用。因为私钥太敏感了，有了私钥相当于可以解密用户发送给服务器的数据，泄漏的危害性非常大。

因此，此类证书文件通常不在办公电脑，或者公司网盘上备份。如果你自己的电脑中有备份，应该尽快删除。通常证书直接保存到安全级别较高的服务器上，只有需要使用证书的软件才能够访问。另外，如果外部的第三方服务需要用到私钥，比如 CDN，那么这里还会涉及一些特别的密钥分发技术，以及硬件加密技术，具体可以参考 Keyless SSL 和 Intel 的 QAT 方案。

## 哪些情况下你服务器的 /etc/passwd 文件会被黑客拿走？

【**解答**】比较常见的情形就是**开发机器信息泄漏或者中毒成了肉鸡**。很多同学的开发机器上都配置了到服务器跳板机的免密登录权限。如果开发机器上公钥泄漏，黑客就有可能登入跳板机。如果成了肉鸡，那么很多行为都可以远程操控，相当于黑客攻破了你公司的内网。

还有一种常见的情形和代码注入有些相似之处，比如说有一个获取配置文件的服务，用参数表示配置文件的名称，比如 /getfile/a.txt 代表取出代码路径某个相对目录的 a.txt。这个时候如果网站程序实现直接将参数作为文件路径的一部分，黑客可能会尝试使用 /getfile/../../../etc/passwd 去获取 /etc/passwd 文件。
