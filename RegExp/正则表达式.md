---
aliases: ['regexp','reg']
tags: ['RegExp','date/2022-12','year/2022','month/12']
date: 2022-12-26-星期一 14:37:49
update: 2022-12-26-星期一 18:45:10
---

## 正则表达式到底是什么

正则表达式 (Regular Expression) 其实就是一门工具，**目的** 是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个 20 世纪 50 年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种 **用来描述规则的表达式**。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。

## 正则表达式规则

### 普通字符

字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是 " 普通字符 "。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。

表达式 `/c/`，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："c"；匹配到的位置是：开始于 2，结束于 3。（注：下标从 0 开始还是从 1 开始，因当前编程语言的不同而可能不同）

### 简单的转义字符

但是如果想要匹配特殊字符的话，就得请出我们第一个元字符 `\` ， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。

我想匹配 `*` 这个符号，由于 `*` 这个符号本身是个特殊字符，所以我要利用转义元字符 `\` 来让它失去其本来的含义：

```js
/\*/
```

如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。

| 特殊字符   | 正则表达式 | 记忆方式                                          |
| ---------- | ---------- | ------------------------------------------------- |
| 换行符     | \\n        | **n**ew line                                      |
| 换页符     | \\f        | **f**orm feed                                     |
| 回车符     | \\r        | **r**eturn                                        |
| 空白符     | \\s        | **s**pace                                         |
| 制表符     | \\t        | **t**ab                                           |
| 垂直制表符 | \\v        | **v**ertical tab                                  |
| 回退符     | \[\\b\]    | **b**ackspace,之所以使用\[\] 符号是避免和\\b 重复 |

还有其他一些在后边章节中有特殊用处的标点符号，在前面加 `"\"` 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 "^" 和 "$" 字符，则表达式就需要写成 `"\^"` 和 `"\$"`。

| 表达式 | 可匹配              |
| ------ | ------------------- |
| `\^`   | 匹配 ^ 符号本身     |
| `\$`   | 匹配 $ 符号本身     |
| `\.`   | 匹配小数点（.）本身 |
| `\\`   | 代表 `"\"` 本身     |

这些转义字符的匹配方法与 " 普通字符 " 是类似的。也是匹配与之相同的一个字符。

### 能够与 ' 多种字符 ' 匹配的表达式

正则表达式中的一些表示方法，可以匹配 ' 多种字符 ' 其中的任意一个字符。比如，表达式 `"\d"` 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。

| 匹配区间                                      | 正则表达式 | 记忆方式            |
| --------------------------------------------- | ---------- | ------------------- |
| 除了换行符之外的任何字符                      | .          | 句号,除了句子结束符 |
| 单个数字, \[0-9\]                             | \\d        | **d**igit           |
| 除了\[0-9\]                                   | \\D        | **not** **d**igit   |
| 包括下划线在内的单个字符，\[A-Za-z0-9\_\]     | \\w        | **w**ord            |
| 非单字字符                                    | \\W        | **not** **w**ord    |
| 匹配空白字符,包括空格、制表符、换页符和换行符 | \\s        | **s**pace           |
| 匹配非空白字符                                | \\S        | **not** **s**pace   |

### 自定义能够匹配 ' 多种字符 ' 的表达式

使用方括号 `[ ]` 包含一系列字符，能够匹配其中任意一个字符。用 `[^ ]` 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。如 `/[123]/` 这个正则就能同时匹配 1,2,3 三个字符。那如果我想匹配所有的数字怎么办呢？从 0 写到 9 显然太过低效，所以元字符 `-` 就可以用来表示区间范围，利用 `/[0-9]/` 就能匹配所有的数字, `/[a-z]/` 则可以匹配所有的英文小写字母。

| 表达式      | 可匹配                                  |
| ----------- | --------------------------------------- |
| `[ab5@]`    | 匹配 "a" 或 "b" 或 "5" 或 "@"           |
| `[^abc]`    | 匹配 "a","b","c" 之外的任意一个字符     |
| `[f-k]`     | 匹配 "f"~"k" 之间的任意一个字母         |
| `[^A-F0-3]` | 匹配 "A"~"F","0"~"3" 之外的任意一个字符 |

### 修饰匹配次数的特殊符号

前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。

使用方法是：" 次数修饰 " 放在 " 被修饰的表达式 " 后边。比如：`"[bcd][bcd]"` 可以写成 `"[bcd]{2}"`。

#### 0 | 1

元字符 `?` 代表了匹配一个字符或 0 个字符。设想一下，如果你要匹配 `color` 和 `colour` 这两个单词，就需要同时保证 `u` 这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：`/colou?r/`。

#### >= 0

元字符 `*` 用来表示匹配 0 个字符或无数个字符。通常用来过滤某些可有可无的字符串。

#### >= 1

元字符 `+` 适用于要匹配同个字符出现 1 次或多次的情况。

#### 特定次数

在某些情况下，我们需要匹配特定的重复次数，元字符 `{` 和 `}` 用来给重复匹配设置精确的区间范围。如 'a' 我想匹配 3 次,那么我就使用 `/a{3}/` 这个正则，或者说 'a' 我想匹配至少两次就是用 `/a{2,}/` 这个正则。

以下是完整的语法：

```
- {x}: x次

- {min, max}： 介于min次到max次之间

- {min, }: 至少min次

- {0, max}： 至多max次
```

由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。

| 匹配规则 | 元字符 | 联想方式 |
| --- | --- | --- |
| 0 次或 1 次 | ? | 且 **问**,此事 **有** 还 **无** |
| 0 次或无数次 | \* | 宇宙洪荒,**辰宿** 列张：宇宙伊始，从无到有，最后星宿布满星空 |
| 1 次或无数次 | + | **一加**, +1 |
| 特定次数 | {x}, {min, max} | 可以想象成一个数轴，从一个点，到一个射线再到线段。min 和 max 分别表示了左闭右闭区间的左界和右界 |

### 多选分支

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。 具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。 例如要匹配字符串 "good" 和 "nice" 可以使用 `/good|nice/`。可以通过分组来限定分支范围 `/goo(d|n)ice/`。

### 位置边界

在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。

#### 单词边界

单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：

```
The cat scattered his food all over the room.
```

<iframe src="https://regex101.com/r/z29WVl/1"
  border="0"
  frameborder="0"
  height="450"
  width="100%"></iframe>

我想找到 `cat` 这个单词，但是如果只是使用 `/cat/` 这个正则，就会同时匹配到 `cat` 和 `scattered` 这两处文本。这时候我们就需要使用边界正则表达式 `\b`，其中 b 是 boundary 的首字母。在正则引擎里它其实匹配的是能构成单词的字符 (\\w) 和不能构成单词的字符 (\\W) 中间的那个位置。

上面的例子改写成 `/\bcat\b/` 这样就能匹配到 `cat` 这个单词了。

#### 字符串边界

匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符 `^` 用来匹配字符串的开头。而元字符 `$` 用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配 `I am scq000` 这个句子：

```
I am scq000.
I am scq000.
I am scq000.
```

我们可以使用 `/^I am scq000\.$/m` 这样的正则表达式，其实 m 是 multiple line 的首字母。正则里面的模式除了 m 外比较常用的还有 i 和 g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。

最后，总结一下：

| 边界和标志 | 正则表达式 | 记忆方式                              |
| ---------- | ---------- | ------------------------------------- |
| 单词边界   | \\b        | **b**oundary                          |
| 非单词边界 | \\B        | **not** **b**oundary                  |
| 字符串开头 | ^          | 小 **头尖尖** 那么大个                |
| 字符串结尾 | $          | **终结**者，美国科幻电影，美元符$     |
| 多行模式   | m 标志     | **m**ultiple of lines                 |
| 忽略大小写 | i 标志     | **i**gnore case, case-**i**nsensitive |
| 全局模式   | g 标志     | **g**lobal                            |

## 正则表达式中的一些高级规则

### 分组

其中分组体现在：所有以 `(` 和 `)` 元字符所包含的正则表达式被分为一组，每一个分组都是一个 **子表达式**，它也是构成高级正则表达式的基础。如果只是使用简单的 `(regex)` 匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。

### 回溯引用

所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像 `\1`,`\2`,….,其中 `\1` 表示引用的第一个子表达式，`\2` 表示引用的第二个子表达式，以此类推。而 `\0` 则表示整个表达式。

假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？

```
Hello what what is the first thing, and I am am scq000.
```

利用回溯引用，我们可以很容易地写出 `\b(\w+)\s\1` 这样的正则。

回溯引用在替换字符串中十分常用，语法上有些许区别，用 `$1`,`$2`…来引用要被替换的字符串。下面以 js 代码作演示：

```js
var str = 'abc abc 123';
str.replace(/(ab)c/g,'$1g');
// 得到结果 'abg abg 123'
```

如果我们不想子表达式被引用，可以使用 **非捕获** 正则 `(?:regex)` 这样就可以避免浪费内存。

```js
var str = 'scq000'.
str.replace(/(scq00)(?:0)/, '$1,$2')
// 返回scq00,$2
// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2
```

有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。

### 断言 (Assertion)

**断言** 有些地方也叫 [环视(Lookaround)](https://blog.csdn.net/lxcnn/article/details/4304754)，它只进行子表达式的匹配，不占有字符，匹配到的内容不保存到最终的匹配结果。

#### 前向查找（lookahead）

**正向前瞻 (positive lookahead)** 是用来限制后缀的。凡是以 `(?=regex)` 包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如 `happy happily` 这两个单词，我想获得以 `happ` 开头的副词，那么就可以使用 `happ(?=ily)` 来匹配。如果我想过滤所有以 `happ` 开头的副词，那么也可以采用 **负向前瞻 (negative lookahead)** 的正则 `happ(?!ily)`，就会匹配到 `happy` 单词的 `happ` 前缀。

例如：

正向前瞻 `\d(?=px)` 1pt ==2==px 3em ==4==px

负向前瞻 `\d(?!px)` ==1==pt 2px ==3==em 4px

#### 后向查找（lookbehind）

接着我们再来介绍一下它的反向操作：后向查找 (lookbehind)。**正向后瞻 (positive lookbehind)** 是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： `apple` 和 `people` 都包含 `ple` 这个后缀，那么如果我只想找到 `apple` 的 `ple`，该怎么做呢？我们可以通过限制 `ap` 这个前缀，就能唯一确定 `ple` 这个单词了。

```
/(?<=ap)ple/
```

其中 `(?<=regex)` 的语法就是我们这里要介绍的后向查找。`regex` 指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向 **后** 查找。另外一种限制匹配是利用 `(?<!regex)` 语法，这里称为 **负向后瞻 (negative lookbehind)**。与正向后瞻不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找 `apple` 的 `ple` 也可以这么写成 `/(?<!peo)ple`。

例如：

正向后瞻 `(?<=ap)ple` ap==ple== people

负向后瞻 `(?<!ap)ple` apple peo==ple==

>ps: 从 es2018 之后，chrome 中的正则表达式也支持后向查找了。不过，在实际项目中还需要注意对旧浏览器的支持，以防线上出现 Bug。详情请查看<http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions>

最后回顾一下这部分内容：

| 回溯查找 | 正则                      | 记忆方式                                                                |
| -------- | ------------------------- | ----------------------------------------------------------------------- |
| 引用     | \\0,\\1,\\2 和 $0, $1, $2 | 转义 + 数字                                                             |
| 非捕获组 | (?:)                      | 引用表达式 (()), 本身不被消费 (?),引用 (:)                              |
| 正向前瞻 | (?=)                      | 引用子表达式 (())，本身不被消费 (?), 正向的查找 (=)                     |
| 负向前瞻 | (?!)                      | 引用子表达式 (())，本身不被消费 (?), 负向的查找 (!)                     |
| 正向后瞻 | (?<=)                     | 引用子表达式 (())，本身不被消费 (?), 后向的 (<，开口往后)，正的查找 (=) |
| 负向后瞻 | (?<!)                     | 引用子表达式 (())，本身不被消费 (?), 后向的 (<，开口往后)，负的查找 (!) |

### 匹配次数中的贪婪与非贪婪

在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：`"{m,n}"`,`"{m,}"`, `"?"`, `"*"`, `"+"`，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 "dxxxdxxxd"，举例如下：

| 表达式        | 匹配结果                                                                                                                                                                          |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(d)(\w+)`    | `"\w+"` 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"                                                                                                                                |
| `(d)(\w+)(d)` | `"\w+"` 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "\w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"\w+" 可以 " 让出 " 它本来能够匹配的最后一个 "d" |

由此可见，`"\w+"` 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 `"*"` 和 `"{m,n}"` 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 " 要匹配 "。这 种匹配原则就叫作 " 贪婪 " 模式 。

非贪婪模式：

在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 " 不匹配 "。这种匹配原则叫作 " 非贪婪 " 模式，也叫作 " 勉强 " 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：

| 表达式        | 匹配结果                                                                                                                                                                          |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `(d)(\w+?)`    | `"\w+?"` 将尽可能少的匹配第一个 "d" 之后的字符，结果是：`"\w+?"` 只匹配了一个 "x"                                                                                                                               |
| `(d)(\w+?)(d)` | 为了让整个表达式匹配成功，`"\w+?"` 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是：`"\w+?"` 匹配 "xxx" |

例如：

`d(\w+)` ==dxxxdxxxd==

`d(\w+?)` ==dx==xx==dx==xxd

### 修饰符 flags

正则表达式除了主体语法，还有若干可选的模式修饰符。

写法就是将修饰符安插在正则主体的尾巴上。比如这样：`/abc/gi`。

#### g 修饰符

`g` 是 `global` 的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。`g` 修饰符会开启全局匹配模式，找到所有匹配的结果。

```js
'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?<=演员)\S+/);
// ["高圆圆", index: 2, input: "演员高圆圆 将军霍去病 演员霍思燕", groups: undefined]
'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?<=演员)\S+/g);
// ["高圆圆", "霍思燕"]
```

#### i 修饰符

`i` 是 `ignoreCase` 的缩写。默认情况下，`/z/` 是无法匹配 `Z` 的，所以我们有时候不得不这样写：`/[a-zA-Z]/`。`i` 修饰符可以全局忽略大小写。

很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。

```js
'javascript is great'.match(/JavaScript/);
// null
'javascript is great'.match(/JavaScript/i);
// ["javascript", index: 0, input: "javascript is great", groups: undefined]
```

#### m 修饰符

`m` 是 `multiline` 的缩写。这个修饰符有特定起作用的场景：它要和 `^` 和 `$` 搭配起来使用。默认情况下，`^` 和 `$` 匹配的是文本的开始和结束，加上 `m` 修饰符，它们的含义就变成了行的开始和结束。

```js
`
abc
xyz
`.match(/xyz/);
// ["xyz", index: 5, input: "↵abc↵xyz↵", groups: undefined]
`
abc
xyz
`.match(/^xyz$/);
// null
`
abc
xyz
`.match(/^xyz$/m);
// ["xyz", index: 5, input: "↵abc↵xyz↵", groups: undefined]
```

#### y 修饰符

> 这是 ES2015 的新特性。

`y` 是 `sticky` 的缩写。`y` 修饰符有和 `g` 修饰符重合的功能，它们都是全局匹配。所以重点在 `sticky` 上，怎么理解这个 `粘连` 呢？

`g` 修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是 `y` 修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。

```js
'a bag with a tag has a mag'.match(/\wag/g);
// ["bag", "tag", "mag"]
'a bag with a tag has a mag'.match(/\wag/y);
// null
'bagtagmag'.match(/\wag/y);
// ["bag", index: 0, input: "bagtagmag", groups: undefined]
'bagtagmag'.match(/\wag/gy);
// ["bag", "tag", "mag"]
```

有人肯定发现了猫腻：你不是说 `y` 修饰符是全局匹配么？看上面的例子，单独一个 `y` 修饰符用 match 方法怎么并不是全局匹配呢？

诶，这里说来就话长了。

长话短说呢，就涉及到 `y` 修饰符的本质是什么。它的本质有二：

- 全局匹配 (先别着急打我)。
- 从文本的 `lastIndex` 位置开始新的匹配。lastIndex 是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。

不知道你们发现什么了没有：**lastIndex 是正则表达式的一个属性**。而上面例子中的 match 方法是作用在字符串上的，都没有 lastIndex 属性，休怪人家工作不上心。

```js
const reg = /\wag/y;
reg.exec('bagtagmag');
// ["bag", index: 0, input: "bagtagmag", groups: undefined]
reg.exec('bagtagmag');
// ["tag", index: 3, input: "bagtagmag", groups: undefined]
reg.exec('bagtagmag');
// ["mag", index: 6, input: "bagtagmag", groups: undefined]
```

咱们换成正则方法 exec，多次执行，正则的 lastIndex 在变，匹配的结果也在变。全局匹配无疑了吧。

#### s 修饰符

> 这是 ES2018 的新特性。

`s` 不是 `dotAll` 的缩写。`s` 修饰符要和 `.` 搭配使用，默认情况下，`.` 匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。

`s` 修饰符的作用就是让 `.` 可以匹配任意单个字符。

`s` 是 `singleline` 的缩写。

```js
`
abc
xyz
`.match(/c.x/);
// null
`
abc
xyz
`.match(/c.x/s);
// ["c↵x", index: 3, input: "↵abc↵xyz↵", groups: undefined]
```

#### u 修饰符

> 这是 ES2015 的新特性。

`u` 是 `unicode` 的缩写。有一些 Unicode 字符超过一个字节，正则就无法正确的识别它们。`u` 修饰符就是用来处理这些不常见的情况的。

```js
'𠮷'.match(/^.$/);
// null
'𠮷'.match(/^.$/u);
// ["𠮷", index: 0, input: "𠮷", groups: undefined]
```

`𠮷` 念 `jí`，与 `吉` 同义。

## JavaScript 方法

在 JavaScript 中，`RegExp` 对象是一个预定义了属性和方法的正则表达式对象。

### String.prototype

#### match

**match** 这个方法主要用来提取数据，它配合分组的（）一起使用，可以很方便的提取数据。

```js
var str = '2022-04-22'
var reg = /^(\d{4})-(\d{2})-(\d{2})$/
console.log(str.match(reg));
//  ['2022-04-22', '2022', '04', '22', index: 0, input: '2022-04-22', groups: undefined]
```

#### replace

**replace** 这个 api 主要用于替换数据，多用于字符串的处理和转义。

```js
var str = '2021-08-14'
var reg = /(\d{4})-(\d{2})-(\d{2})/g
console.log(str.replace(reg,"$2/$3/$1"))
// 08/14/2021
```

**$1**,**$2** 上就是按顺序对应小括号里面的 **分组** 捕获到的内容。这里我们将 2 组和 1 组进行内容替换，就得到了替换后的内容。

#### split

**split** 主要用于来切分字符串为数组，它的第一个参数也可以为正则的形式。

```js
const str1 = '2022-04-21'
const str2 = '2022.04.22'
const str3 = '2022/04/23'
const regsSplit = /[\.\-\/]/
console.log(str1.split(regsSplit))
console.log(str2.split(regsSplit))
console.log(str3.split(regsSplit))
// ['2022', '04', '21']
// ['2022', '04', '22']
// ['2022', '04', '23']
```

### RegExp.prototype

#### test()

该方法用于检测一个字符串是否匹配某个正则表达式，**匹配** 返回 true，**不匹配** 返回 false。

```js
console.log(/d+/.test('18 years old'))
// true
```

#### exec()

该方法用于检测字符串中对正则表达式的匹配。

该函数返回一个 **数组**，其中存放匹配的结果。如果未找到匹配，则返回值为 null。

除了正则自身携带的方法，配合 **String 对象** 的方法一起使用也会有额外的效果。

```js
console.log(/good/.exec("JavaScript is good"));
// ['good', index: 14, input: 'JavaScript is good', groups: undefined]
```

#### @@split

`@@split` 方法切割 String 对象为一个其子字符串的数组 。

```js
var re = /-/g;
var str = '2022-01-02';
var result = re[Symbol.split](str);
console.log(result);  // ["2022", "01", "02"]
```

#### @@match

对正则表达式匹配字符串时，`@@match` 方法用于获取匹配结果。

```js
var re = /[0-9]+/g;
var str = '2022-01-02';
var result = re[Symbol.match](str);
console.log(result);  // ["2022", "01", "02"]
```

#### @@search

`@@search` 方法执行了一个在给定字符串中的一个搜索以取得匹配正则模式的项。

```js
var re = /-/g;
var str = '2016-01-02';
var result = re[Symbol.search](str);
console.log(result);  // 4
```

#### @@replace

`@@replace` 方法会在一个字符串中用给定的替换器，替换所有符合正则模式的匹配项，并返回替换后的新字符串结果。用来替换的参数可以是一个字符串或是一个针对每次匹配的回调函数。

```js
var re = /-/g; 
var str = '2016-01-01';
var newstr = re[Symbol.replace](str, '.');
console.log(newstr);  // 2016.01.01
```

#### flags

`flags` 属性返回一个字符串，由当前正则表达式对象的标志组成。

```js
/foo/ig.flags;   // "gi"
/bar/myu.flags;  // "muy"
```

#### dotAll

正则中的点匹配就是 `dotAll` ，都是匹配任意字符，但是很多字符是无法匹配的。例如：

- 四个字节的 `UTF-16` 的字符
- 行终止符 `\n` `\r` 换行 回车

```js
console.log(/foo.bar/.test('foo\nbar'))
// false
console.log(/foo.bar/.test('fooabar'))
// true
```

加上 `s` 可以匹配换行符

```js
console.log(/foo.bar/s.test('foo\nbar'))
// true
```

## 正则表达式思维导图

![[e9aad25bbf114aaaadc168333771830f_tplv-k3u1fbpfcp-zoom-1.png|800]]

![[34f7904e24954b85b13d20decd1290fd_tplv-k3u1fbpfcp-zoom-1.png|800]]

![[2f7a2d325d104c97bf65a8a692037d1f_tplv-k3u1fbpfcp-zoom-1.png|800]]

## 正则表达式网站推荐

正则可视化及测试工具

[regexper.com](https://regexper.com/)

[regex101.com](https://regex101.com/)

[regexr](https://regexr.com/)

## 参考

<http://www.regexlab.com/zh/regref.htm>

<https://juejin.cn/post/7132628898453880840>

<https://juejin.cn/post/6844903845227659271>

<https://juejin.cn/post/7169605642808721421>
