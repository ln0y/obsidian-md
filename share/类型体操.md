---
aliases: []
tags: ['share', 'TypeScript', 'date/2022-08', 'year/2022', 'month/08']
date: 2022-08-03-星期三 10:18:56
update: 2023-09-20-星期三 00:53:52
---

类型系统不止 TypeScript 有，别的语言 Java、C++ 等都有，为什么 TypeScript 的类型编程被叫做类型体操，而其他语言没有呢？

TypeScript 给 JavaScript 增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。

它并没有改变 JavaScript 的语法，只是在 JS 的基础上添加了类型语法，所以被叫做 JavaScript 的超集。

JavaScript 的标准在不断的发展，TypeScript 的类型系统也在不断完善，因为“超集”的设计理念，这两者可以很好的融合在一起，是不会有冲突的。

静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：

## 简单类型系统

变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时会报错。

这是最基础的类型系统，能保证类型安全，但有些死板。

比如一个 add 函数既可以做整数加法、又可以做浮点数加法，却需要声明两个函数：

```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}
```

这个问题的解决思路很容易想到：如果类型能传参数就好了，传入 int 就是整数加法，传入 double 就是浮点数加法。

所以，就有了第二种类型系统。

## 支持泛型的类型系统

泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做 `类型参数`。

它给类型系统增加了一些灵活性，在整体比较固定，部分变量的类型有变化的情况下，可以减少很多重复代码。

比如上面的 add 函数，有了泛型之后就可以这样写：

```cpp
T add<T>(T a, T b) {
    return a + b;
}

add(1,2);
add(1.111, 2.2222);
```

**声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。**

Java 就是这种类型系统。

但是，这种类型系统的灵活性对于 JavaScript 来说还不够，因为 JavaScript 太过灵活了。

比如，在 Java 里，对象都是由类 new 出来的，你不能凭空创建对象，但是 JavaScript 却可以，它支持对象字面量。

那如果是一个返回对象某个属性值的函数，类型该怎么写呢？

```ts
function getPropValue<T>(obj: T, key): key对应的属性值类型 {
    return obj[key];
}
```

好像拿到了 T，也不能拿到它的属性和属性值，如果能对类型参数 T 做一些逻辑处理就好了。

所以，就有了第三种类型系统。

## 支持类型编程的类型系统

在 Java 里面，拿到了对象的类型就能找到它的类，进一步拿到各种信息，所以类型系统支持泛型就足够了。

但是在 JavaScript 里面，对象可以字面量的方式创建，还可以灵活的增删属性，拿到对象并不能确定什么，所以要支持对传入的类型参数做进一步的处理。

**对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。**

比如上面那个 getProps 的函数，类型可以这样写：

```ts
function getPropValue<
    T extends object,
    Key extends keyof T
>(obj: T, key: Key): T[Key] {
    return obj[key];
}
```

这里的 keyof T、T\[Key\] 就是对类型参数 T 的类型运算。

TypeScript 的类型系统就是第三种，支持对类型参数做各种逻辑处理，可以写很复杂的类型逻辑。

**类型逻辑可以多复杂？**

类型逻辑是对类型参数的各种处理，可以实现很多强大的功能：

比如这个 ParseQueryString 的类型：

<iframe src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4QIoFcIJAZWAgSwDsBzAHgBUoIAPYCIgEySiX2JID4oBeKK2vSYsABgBIA3sQBmWWIjgBbAL4AySTLkAlCG2UiAUFCgB+KAFksJCPARKkZWyltLHCxZwA085GkzY8QlIyHTZOTiMoAC4fZ3dKCINQSFibeIE6BmZWdlJuPgyhbPEpIlkEKABpZR4NMrkANX1TKB0AYwB7BEYySu8G7hiJZQMk8GhLBGsXRQcYAEZqTOEoDoAjACsINuBvGAAmJaKWda2d-KgJSIBtSqhiKABrCBAO6Vh5gF0Yu8Eslmer3eB0ixjM1wWt0+3gAdHCABQHKFHf5QOBEEDXT4tJGVbExCH7KGfACUn1B0Q+UIMyigqkuNwa9yITxeb1ghzgLCZfxWgPZCxaRAgADc5DEGt8OddJTTRskJlYIABJIgoBDAAgdNUJXj8FErU7bYAtCRQW7M1lA-hSybWVXqzXahwUKHcWkxCjy8ZQehsPXXSJ2lVqrBOnVONJ2RRkADkcB481j4U8QaVDrDWojiBQGCwuFy5HjieTXjTUxDjqzcxzfnzgQ4cYT81Uax4+1UbR4AGZS6njMGMxrq25fHmAoWm4nVAmO22O13eyny-bQ8PnaPc-4C0Ei83W+2Dwue6WDOSgA"
  border="0"
  frameborder="0"
  height="700"
  width="100%"></iframe>

它可以对传入的字符串的类型参数做解析，返回解析以后的结果。

如果是 Java 的只支持泛型的类型系统可以做到么？明显不能。但是 TypeScript 的类型系统就可以，因为它可以对泛型（类型参数）做各种逻辑处理。

**TypeScript 的类型系统是 ` 图灵完备` 的，也就是能描述各种可计算逻辑。简单点来理解就是循环、条件等各种 JS 里面有的语法它都有，JS 能写的逻辑它都能写。**

对类型参数的编程是 TypeScript 类型系统最强大的部分，可以实现各种复杂的类型计算逻辑，是它的优点。但同时也被认为是它的缺点，因为除了业务逻辑外还要写很多类型逻辑。

不过，这种复杂度是不可避免的，因为 JS 本身足够灵活，要准确定义类型那类型系统必然也要设计的足够灵活。

但是很多类型编程的逻辑写起来比较复杂，因此被戏称为类型体操。

## TypeScript 类型系统中的类型

静态类型系统的目的是把类型检查从运行时提前到编译时，那 TS 类型系统中肯定要把 JS 的运行时类型拿过来，也就是 number、boolean、string、object、bigint、symbol、undefined、null 这些拆箱类型，还有就是它们的装箱类型 Number、Boolean、String、Object、Symbol（不建议使用）。

这些很容易理解，给 JS 添加静态类型，总没有必要重新造一套基础类型吧，直接复用 JS 的基础类型就行。

复合类型方面，JS 有 class、Array，这些 TypeScript 类型系统也都支持，但是又多加了三种类型：元组（Tuple）、接口（Interface）、枚举（Enum）。

### 元组

` 元组（Tuple）` 就是元素个数和类型固定的数组类型：

```ts
type Tuple = [number, string];
```

### 接口

` 接口（Interface）` 可以描述函数、对象、构造器的结构：

对象：

```ts
interface IPerson {
    name: string;
    age: number;
}

class Person implements IPerson {
    name: string;
    age: number;
}

const obj: IPerson = {
    name: 'tony',
    age: 18
}
```

函数：

```ts
interface SayHello {
    (name: string): string;
}

const func: SayHello = (name: string) => {
    return 'hello,' + name
}
```

构造器：

```ts
interface PersonConstructor {
    new (name: string, age: number): IPerson;
}

function createPerson(ctor: PersonConstructor):IPerson {
    return new ctor('tony', 18);
}
```

对象类型、class 类型在 TypeScript 里也叫做索引类型，也就是索引了多个元素的类型的意思。对象可以动态添加属性，如果不知道会有什么属性，可以用可索引签名：

```ts
interface IPerson {
    [prop: string]: string | number;
}
const obj:IPerson = {};
obj.name = 'tony';
obj.age = 18;
```

总之，**接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型**。

### 枚举

` 枚举（Enum）` 是一系列值的复合：

```ts
enum Transpiler {
    Babel = 'babel',
    Postcss = 'postcss',
    Terser = 'terser',
    Prettier = 'prettier',
    TypeScriptCompiler = 'tsc'
}

const transpiler = Transpiler.TypeScriptCompiler;
```

此外，TypeScript 还支持 ` 字面量类型`，也就是类似 1111、'aaaa'、{ a: 1} 这种值也可以做为类型。

其中，字符串的字面量类型有两种，一种是普通的字符串字面量，比如 'aaa'，另一种是模版字面量，比如 `aaa${string}`，它的意思是以 aaa 开头，后面是任意 string 的字符串字面量类型。

还有四种特殊的类型：void、never、any、unknown：

- **never** 代表不可达，比如函数抛异常的时候，返回值就是 never。
- **void** 代表空，可以是 undefined 或 never。
- **any** 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。
- **unknown** 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。

这些就是 TypeScript 类型系统中的全部类型了，大部分是从 JS 中迁移过来的，比如基础类型、Array、class 等，也添加了一些类型，比如 枚举（enum）、接口（interface）、元组等，还支持了字面量类型和 void、never、any、unknown 的特殊类型。

### 类型的装饰

除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：

```ts
interface IPerson {
    readonly name: string;
    age?: number;
}

type tuple = [string, number?];
```

## 类型别名

类型别名可以说是 TypeScript 类型编程中最重要的一个功能，从一个简单的函数类型别名，到让你眼花缭乱的类型体操，都离不开类型别名。虽然很重要，但它的使用却并不复杂：

```ts
type A = string;
```

我们通过 `type` 关键字声明了一个类型别名 A ，同时它的类型等价于 string 类型。类型别名的作用主要是对一组类型或一个特定类型结构进行封装，以便于在其它地方进行复用。

比如抽离一组联合类型：

```ts
type StatusCode = 200 | 301 | 400 | 500 | 502;
type PossibleDataTypes = string | number | (() => unknown);

const status: StatusCode = 502;
```

抽离一个函数类型：

```ts
type Handler = (e: Event) => void;

const clickHandler: Handler = (e) => { };
const moveHandler: Handler = (e) => { };
const dragHandler: Handler = (e) => { };
```

声明一个对象类型，就像接口那样：

```ts
type ObjType = {
  name: string;
  age: number;
}
```

看起来类型别名真的非常简单，不就是声明了一个变量让类型声明更简洁和易于拆分吗？如果真的只是把它作为类型别名，用来进行特定类型的抽离封装，那的确很简单。然而，类型别名还能作为工具类型。**工具类同样基于类型别名，只是多了个泛型**。

在类型别名中，类型别名可以这么声明自己能够接受泛型（我称之为泛型坑位）。一旦接受了泛型，我们就叫它工具类型：

```ts
type Factory<T> = T | number | string;
```

虽然现在类型别名摇身一变成了工具类型，但它的基本功能仍然是创建类型，只不过工具类型能够接受泛型参数，实现 **更灵活的类型创建功能**。从这个角度看，工具类型就像一个函数一样，泛型是入参，内部逻辑基于入参进行某些操作，再返回一个新的类型。比如在上面这个工具类型中，我们就简单接受了一个泛型，然后把它作为联合类型的一个成员，返回了这个联合类型。

```ts
const foo: Factory<boolean> = true;
```

当然，我们一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名：

```ts
type FactoryWithBool = Factory<boolean>;

const foo: FactoryWithBool = true;
```

同时，泛型参数的名称（上面的 T ）也不是固定的。通常我们使用大写的 T / K / U / V / M / O …这种形式。如果为了可读性考虑，我们也可以写成大驼峰形式（即在驼峰命名的基础上，首字母也大写）的名称，比如：

```ts
type Factory<NewType> = NewType | number | string;
```

声明一个简单、有实际意义的工具类型：

```ts
type MaybeNull<T> = T | null;
```

这个工具类型会接受一个类型，并返回一个包括 null 的联合类型。这样一来，在实际使用时就可以确保你处理了可能为空值的属性读取与方法调用：

```ts
type MaybeNull<T> = T | null;

function process(input: MaybeNull<{ handler: () => {} }>) {
  input?.handler();
}
```

类似的还有 MaybePromise、MaybeArray。这也是我们在日常开发中最常使用的一类工具类型：

```ts
type MaybeArray<T> = T | T[];

function ensureArray<T>(input: MaybeArray<T>): T[] {
  return Array.isArray(input) ? input : [input];
}
```

另外，类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值等。

总之，对于工具类型来说，它的主要意义是 **基于传入的泛型进行各种类型操作**，得到一个新的类型。而这个类型操作的指代就非常非常广泛了，甚至说类型编程的大半难度都在这儿。

## 联合类型与交叉类型

联合类型还有一个和它有点像的孪生兄弟：**交叉类型**。它和联合类型的使用位置一样，只不过符号是 `&`，即按位与运算符。

实际上，正如联合类型的符号是 `|`，它代表了按位或，即只需要符合联合类型中的一个类型，既可以认为实现了这个联合类型，如 `A | B`，只需要实现 A 或 B 即可。

而代表着按位与的 `&` 则不同，你需要符合这里的所有类型，才可以说实现了这个交叉类型，即 `A & B`，**需要同时满足 A 与 B 两个类型** 才行。

我们声明一个交叉类型：

```ts
interface NameStruct {
  name: string;
}

interface AgeStruct {
  age: number;
}

type ProfileStruct = NameStruct & AgeStruct;

const profile: ProfileStruct = {
  name: "tony",
  age: 18
}
```

很明显这里的 profile 对象需要同时符合这两个对象的结构。从另外一个角度来看，ProfileStruct 其实就是一个新的，同时包含 NameStruct 和 AgeStruct 两个接口所有属性的类型。这里是对于对象类型的合并，那对于原始类型呢？

```ts
type StrAndNum = string & number; // never
```

我们可以看到，它竟然变成 never 了！看起来很奇怪，但想想我们前面给出的定义，新的类型会同时符合交叉类型的所有成员，存在既是 string 又是 number 的类型吗？当然不。实际上，这也是 never 这一 BottomType 的实际意义之一，描述 **根本不存在的类型** 嘛。

对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并：

```ts
type Struct1 = {
  primitiveProp: string;
  objectProp: {
    name: string;
  }
}

type Struct2 = {
  primitiveProp: number;
  objectProp: {
    age: number;
  }
}

type Composed = Struct1 & Struct2;

type PrimitivePropType = Composed['primitiveProp']; // never
type ObjectPropType = Composed['objectProp']; // { name: string; age: number; }
```

如果是两个联合类型组成的交叉类型呢？其实还是类似的思路，既然只需要实现一个联合类型成员就能认为是实现了这个联合类型，那么各实现两边联合类型中的一个就行了，也就是两边联合类型的交集：

```ts
type UnionIntersection1 = (1 | 2 | 3) & (1 | 2); // 1 | 2
type UnionIntersection2 = (string | number | symbol) & string; // string
```

总结一下交叉类型和联合类型的区别就是，联合类型只需要符合成员之一即可（`||`），而交叉类型需要严格符合每一位成员（`&&`）。

## 索引类型

索引类型指的不是某一个特定的类型工具，它其实包含三个部分：**索引签名类型**、**索引类型查询** 与 **索引类型访问**。目前很多社区的学习教程并没有这一点进行说明，实际上这三者都是独立的类型工具。唯一共同点是，**它们都通过索引的形式来进行类型操作**，但索引签名类型是 **声明**，后两者则是 **读取**。接下来，我们来依次介绍三个部分。

### 索引签名类型

索引签名类型主要指的是在接口或类型别名中，通过以下语法来 **快速声明一个键值类型一致的类型结构**：

```ts
interface AllStringTypes {
  [key: string]: string;
}

type AllStringTypes = {
  [key: string]: string;
}
```

这时，即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 string 类型：

```ts
interface AllStringTypes {
  [key: string]: string;
}

type PropType1 = AllStringTypes['tony']; // string
type PropType2 = AllStringTypes['599']; // string
```

在这个例子中我们声明的键的类型为 string（`[key: string]`），这也意味着在实现这个类型结构的变量中 **只能声明字符串类型的键**：

```ts
interface AllStringTypes {
  [key: string]: string;
}

const foo: AllStringTypes = {
  "tony": "599"
}
```

但由于 JavaScript 中，对于 `obj[prop]` 形式的访问会将 **数字索引访问转换为字符串索引访问**，也就是说， `obj[599]` 和 `obj['599']` 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此：

```ts
const foo: AllStringTypes = {
  "tony": "599",
  599: "tony",
  [Symbol("ddd")]: 'symbol',
}
```

索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明：

```ts
interface AllStringTypes {
  // 类型“number”的属性“propA”不能赋给“string”索引类型“boolean”。
  propA: number;
  [key: string]: boolean;
}
```

这里的符合即指子类型，因此自然也包括联合类型：

```ts
interface StringOrBooleanTypes {
  propA: number;
  propB: boolean;
  [key: string]: number | boolean;
}
```

索引签名类型的一个常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 any 的索引签名类型，以此来暂时支持 **对类型未明确属性的访问**，并在后续一点点补全类型：

```ts
interface AnyTypeHere {
  [key: string]: any;
}

const foo: AnyTypeHere['tony'] = 'any value';
```

### 索引类型查询

刚才我们已经提到了索引类型查询，也就是 keyof 操作符。严谨地说，它可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。注意，**这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量**。

```ts
interface Foo {
  tony: 1,
  599: 2
}

type FooKeys = keyof Foo; // "tony" | 599
```

> [!INFO]+ 注
> 在这里 `FooKeys` 会显示 `keyof Foo` 没有显示 `"tony" | 599`，这是 ts 做了性能优化，ts 只有类型被用到的时候才会做类型计算，因此可以通过 `extends` 强制触发计算
>
> ```ts
> type forceKeyof<T, U = keyof T> = U extends any ? U : never
> type FooKeys = forceKeyof\<Foo> // "tony"  |  599
> ```
>
> <br/>

如果觉得不太好理解，我们可以写段伪代码来模拟 **“从键名到联合类型”** 的过程。

```ts
type FooKeys = Object.keys(Foo).join(" | ");
```

除了应用在已知的对象类型结构上以外，你还可以直接 `keyof any` 来生产一个联合类型，它会由所有可用作对象键值的类型组成：`string | number | symbol`。也就是说，它是由无数字面量类型组成的，由此我们可以知道， **keyof 的产物必定是一个联合类型**。

### 索引类型访问

在 JavaScript 中我们可以通过 `obj[expression]` 的方式来动态访问一个对象属性（即计算属性），expression 表达式会先被执行，然后使用返回值来访问属性。而 TypeScript 中我们也可以通过类似的方式，只不过这里的 expression 要换成类型。接下来，我们来看个例子：

```ts
interface NumberRecord {
  [key: string]: number;
}

type PropType = NumberRecord[string]; // number
```

这里，我们使用 string 这个类型来访问 NumberRecord。由于其内部声明了数字类型的索引签名，这里访问到的结果即是 number 类型。注意，其访问方式与返回值均是类型。

更直观的例子是通过字面量类型来进行索引类型访问：

```ts
interface Foo {
  propA: number;
  propB: boolean;
}

type PropAType = Foo['propA']; // number
type PropBType = Foo['propB']; // boolean
```

看起来这里就是普通的值访问，但实际上这里的 `'propA'` 和 `'propB'` 都是 **字符串字面量类型**，**而不是一个 JavaScript 字符串值**。索引类型查询的本质其实就是，**通过键的字面量类型（`'propA'`）访问这个键对应的键值类型（`number`）**。

看到这你肯定会想到，上面的 keyof 操作符能一次性获取这个对象所有的键的字面量类型，是否能用在这里？当然，这可是 TypeScript 啊。

```ts
interface Foo {
  propA: number;
  propB: boolean;
  propC: string;
}

type PropTypeUnion = Foo[keyof Foo]; // string | number | boolean
```

使用字面量联合类型进行索引类型访问时，其结果就是将联合类型每个分支对应的类型进行访问后的结果，重新组装成联合类型。**索引类型查询、索引类型访问通常会和映射类型一起搭配使用**，前两者负责访问键，而映射类型在其基础上访问键值类型，我们在下面一个部分就会讲到。

注意，在未声明索引签名类型的情况下，我们不能使用 `NumberRecord[string]` 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。

```ts
interface Foo {
  propA: number;
}

// 类型“Foo”没有匹配的类型“string”的索引签名。
type PropAType = Foo[string];
```

索引类型的最佳拍档之一就是映射类型，同时映射类型也是类型编程中常用的一个手段。

## type 与 interface

### 相似处

#### 1. 都可以描述 `Object` 和 `Function`

两者都可以用来描述对象或函数,但语法不同:

**Type**

```ts
type Point = {
  x: number;
  y: number;
};

type SetPoint = (x: number, y: number) => void;
```

**Interface**

```ts
interface Point {
  x: number;
  y: number;
}

interface SetPoint {
  (x: number, y: number): void;
}
```

#### 2. 二者都可以被继承

`interface` 和 `type` 都可以继承。

另一个值得注意的是，接口和类型别名并不互斥。类型别名可以继承接口，反之亦然。只是在实现形式上，稍微有些差别。

**interface 继承 interface**

```ts
interface Person{
    name:string
}

interface Student extends Person { stuNo: number }
```

**interface 继承 type**

```ts
type Person{
    name:string
}

interface Student extends Person { stuNo: number }
```

**type 继承 type**

```ts
type Person{
    name:string
}

type Student = Person & { stuNo: number }
```

**type 继承 interface**

```ts
interface Person{
    name:string
}

type Student = Person & { stuNo: number }
```

#### 3. 实现 implements

类可以实现 `interface` 以及 `type`(除联合类型外)

```ts
interface ICat{
    setName(name:string): void;
}

class Cat implements ICat{
    setName(name:string):void{
        // todo
    }
}

// type
type ICat = {
    setName(name:string): void;
}

class Cat implements ICat{
    setName(name:string):void{
        // todo
    }
}
```

上面提到了特殊情况，` 类无法实现联合类型 `, 是什么意思呢？

```ts
type Person = { name: string; } | { setName(name:string): void };

// 无法对联合类型Person进行实现
// error: A class can only implement an object type or intersection of object types with statically known members.
class Student implements Person {
  name= "张三";
  setName(name:string):void{
        // todo
    }
}
```

### 二者区别

#### 1. 定义基本类型别名

`type` 可以定义 **基本类型别名**, 但是 `interface` 无法定义,如：

```ts
type userName = string
type stuNo = number
...
```

#### 2. 声明联合类型

`type` 可以声明 **联合类型**, 例如：

```ts
type Student = {stuNo: number} | {classId: number}
```

#### 3. 声明元组

type 可以申明 **元组类型**：

```ts
type Data = [number, string];
```

以上都是 `type` 能做到， 而 `interface` 做不到的， 接下来聊聊 `type` 做不到的

#### 4. 声明合并

如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为 **声明合并**， 例如：

```ts
interface Person { name: string }
interface Person { age: number }

let user: Person = {
    name: "Tolu",
    age: 0,
};
```

这种情况下，如果是 `type` 的话，重复使用 `Person` 是会报错的：

```ts
type Person { name: string };

// Error: 标识符“Person”重复。ts(2300)
type Person { age: number }
```

#### 5. 索引签名问题

如果你经常使用 TypeScript, 一定遇到过相似的错误：

> Type 'xxx' is not assignable to type 'yyy'
>
> Index signature is missing in type 'xxx'.

看个例子来理解问题：

```ts
interface propType{
    [key: string] : string
}

let props: propType

type dataType = {
    title: string
}
interface dataType1 {
    title: string
}
const data: dataType = {title: "订单页面"}
const data1: dataType1 = {title: "订单页面"}
props = data
// Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名
props = data1
```

我们发现 `dataType` 和 `dataType1` 对应的类型一样，但是 `interface` 定义的就赋值失败，是什么原因呢？ stack overflow 上找到了一个相似的问题：

<iframe src="https://stackoverflow.com/questions/64970414/typescript-assigning-an-interface-or-a-type-to-a-recordstring-string"
  border="0"
  frameborder="0"
  height="650"
  width="100%"></iframe>

翻译过来的大致意思就是：

> `Record<string,string>` 与 `{[key:string]：string}` 相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从 `exampleType` 到 `Record<string,string>` 的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。
>
> 相反，**在你使用 interface 去声明变量时，它们在那一刻类型并不是最终的类型**。由于 interfac 可以进行 **声明合并**，所以总有可能将新成员添加到同一个 interface 定义的类型上。

再结合👆`第 4点 声明合并 ` 的讲解, 这样就很好理解了。 就是说 `interface` 定义的类型是不确定的， 后面再来一个：

```ts
interface propType{
    title:number
}
```

这样 `propType` 类型就被改变了。

### 建议

很多人更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而这里更推荐的方式是，interface 用来描述 **对象、类的结构**，而类型别名用来 **将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型**。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题

## TypeScript 类型系统中的类型运算

我们知道了 TypeScript 类型系统里有哪些类型，那么可以对这些类型做什么类型运算呢？

### 条件：extends ?

TypeScript 里的条件判断是 `extends ? :`，叫做条件类型（Conditional Type）比如：

```ts
type res = 1 extends 2 ? true : false; // false
```

这就是 TypeScript 类型系统里的 if else。

但是，上面这样的逻辑没啥意义，静态的值自己就能算出结果来，为什么要用代码去判断呢？

所以，类型运算逻辑都是用来做一些动态的类型的运算的，也就是对类型参数的运算。

```ts
type isTwo<T> = T extends 2 ? true: false;

type res = isTwo<1>; // false
type res2 = isTwo<2>; // true
```

这种类型也叫做 `高级类型`。

**高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回新的类型。**

### 推导：infer

如何提取类型的一部分呢？答案是 infer。

比如提取元组类型的第一个元素：

```ts
type First<Tuple extends unknown[]> = Tuple extends [infer T,...infer R] ? T : never;

type res = First<[1,2,3]>; // 1
```

注意，第一个 extends 不是条件，条件类型是 `extends ? :`，这里的 extends 是约束的意思，也就是约束类型参数只能是数组类型。

因为不知道数组元素的具体类型，所以用 unknown。

### 联合：｜

联合类型（Union）类似 js 里的或运算符 |，但是作用于类型，代表类型可以是几个类型之一。

```ts
type Union = 1 | 2 | 3;
```

### 交叉：&

交叉类型（Intersection）类似 js 中的与运算符 &，但是作用于类型，代表对类型做合并。

```ts
type ObjType = {a: number } & {c: boolean}; // {a: number; c: boolean;}
```

注意，同一类型可以合并，不同的类型没法合并，会被舍弃：

```ts
type res = {a: number } & {c: boolean}; // {a: number; c: boolean;}
```

### 映射类型

对象、class 在 TypeScript 对应的类型是索引类型（Index Type），那么如何对索引类型作修改呢？

答案是 `映射类型`。

```ts
type MapType<T> = {
  [Key in keyof T]?: T[Key]
}
```

keyof T 是查询索引类型中所有的索引，叫做 `索引查询`。

T\[Key\] 是取索引类型某个索引的值，叫做 `索引访问`。

in 是用于遍历联合类型的运算符。

比如我们把一个索引类型的值变成 3 个元素的数组：

```ts
type MapType<T> = {
    [Key in keyof T]: [T[Key], T[Key], T[Key]]
}

type res = MapType<{a: 1, b: 2}>;
// {
//   a: [1, 1, 1];
//   b: [2, 2, 2];
// }
```

**映射类型就相当于把一个集合映射到另一个集合，这是它名字的由来**。

除了值可以变化，索引也可以做变化，用 as 运算符，叫做 `重映射`。

```ts
type MapType<T> = {
    [Key in keyof T as `${Key & string}${Key & string}${Key & string}`]: [T[Key], T[Key], T[Key]]
}
```

我们用 as 把索引也做了修改，改成了 3 个 key 重复：

```ts
type MapType<T> = {
    [Key in keyof T as `${Key & string}${Key & string}${Key & string}`]: [T[Key], T[Key], T[Key]]
}

type res = MapType<{ a: 1, b: 2 }>;
```

这里的 & string 可能会迷惑，解释一下：

因为索引类型（对象、class 等）可以用 string、number 和 symbol 作为 key，这里 keyof T 取出的索引就是 string | number | symbol 的联合类型，和 string 取交叉部分就只剩下 string 了。就像前面所说，交叉类型会把同一类型做合并，不同类型舍弃。

因为 js 处理对象比较多，所以索引类型的映射比较重要。

## 逆变、协变、双向协变、不变

![[类型兼容#变型]]

## TypeScript 内置高级类型

### Parameters

Parameters 用于提取函数类型的参数类型。

源码是这样的：

```ts
type Parameters<T extends (...args: any) => any>
    = T extends (...args: infer P) => any
        ? P
        : never;
```

类型参数 T 为待处理的类型，通过 extends 约束为函数，参数和返回值任意。

通过 extends 匹配一个模式类型，提取参数的类型到 infer 声明的局部变量 P 中返回。

这样就实现了函数参数类型的提取：

```ts
type ParametersRes = Parameters<(name: string, age: number) => {}>; // [name: string, age: number]
```

### ReturnType

ReturnType 用于提取函数类型的返回值类型。

源码是这样的：

```ts
type ReturnType<T extends (...args: any) => any>
    = T extends (...args: any) => infer R
        ? R
        : any;
```

类型参数 T 为待处理的类型，通过 extends 约束为函数类型，参数和返回值任意。

用 T 匹配一个模式类型，提取返回值的类型到 infer 声明的局部变量 R 里返回。

这样就实现了函数返回值类型的提取：

```ts
type ReturnTypeRes = ReturnType<() => 'type'>; // type
```

和提取函数参数类型差不多，也是个简单的模式匹配。

### ConstructorParameters

构造器类型和函数类型的区别就是可以被 new。

Parameters 用于提取函数参数的类型，而 ConstructorParameters 用于提取构造器参数的类型。

源码是这样的：

```ts
type ConstructorParameters<
    T extends abstract new (...args: any) => any
> = T extends abstract new (...args: infer P) => any
    ? P
    : never;
```

类型参数 T 是待处理的类型，通过 extends 约束为构造器类型，加个 abstract 代表不能直接被实例化（其实不加也行）。

用 T 匹配一个模式类型，提取参数的部分到 infer 声明的局部变量 P 里，返回 P。

这样就实现了构造器参数类型的提取：

```ts
interface Person {
    name: string;
}

interface PersonConstructor {
    new(name: string): Person;
}

type ConstructorParametersRes = ConstructorParameters<PersonConstructor>; // [name: string]
```

构造器参数的提取依然是模式匹配。

### InstanceType

提取了构造器参数的类型，自然也可以提取构造器返回值的类型，就是 InstanceType。

源码是这样的：

```ts
type InstanceType<
    T extends abstract new (...args: any) => any
> = T extends abstract new (...args: any) => infer R
    ? R
    : any;
```

整体和 ConstructorParameters 差不多，只不过提取的不再是参数了，而是返回值。

通过模式匹配提取返回值的类型到 infer 声明的局部变量 R 里返回。

这样就实现了构造器的实例类型的提取：

```ts
interface Person {
    name: string;
}

interface PersonConstructor {
    new(name: string): Person;
}

type InstanceTypeRes = InstanceType<PersonConstructor>; // Person
```

### ThisParameterType

函数里可以调用 this，这个 this 的类型也可以约束：

```ts
type Person = {
    name: 'tony'
}

function hello(this: Person) {
    return this.name
}
```

同样，this 的类型也可以提取出来，通过 ThisParameterType 这个内置的高级类型：

```ts
type Person = {
    name: 'tony'
}

function hello(this: Person) {
    return this.name
}

type ThisParameterTypeRes = ThisParameterType<typeof hello> // Person
```

它的源码是这样的：

```ts
type ThisParameterType<T> =
    T extends (this: infer U, ...args: any[]) => any
        ? U
        : unknown;
```

类型参数 T 为待处理的类型。

用 T 匹配一个模式类型，提取 this 的类型到 infer 声明的局部变量 U 里返回。

这样就实现了 this 类型的提取。

### OmitThisParameter

提取出 this 的类型之后，自然可以构造一个新的，比如删除 this 的类型可以用 OmitThisParameter。

它的源码是这样的：

```ts
type OmitThisParameter<T> =
    unknown extends ThisParameterType<T>
        ? T
        : T extends (...args: infer A) => infer R
            ? (...args: A) => R
            : T;
```

类型参数 T 为待处理的类型。

用 ThisParameterType 提取 T 的 this 类型，如果提取出来的类型是 unknown 或者 any，那么 unknown extends ThisParameterType 就成立，也就是没有指定 this 的类型，所以直接返回 T。

否则，就通过模式匹配提取参数和返回值的类型到 infer 声明的局部变量 A 和 R 中，用它们构造新的函数类型返回。

这样，就实现了去掉 this 类型的目的：

```ts
type Person = {
    name: 'tony'
}

function hello(this: Person, age: number) {
    return this.name + age
}

type OmitThisParameterRes = OmitThisParameter<typeof hello> // (age: number) => string
```

这个类型除了模式匹配做提取外，也用到了重新构造做变换，稍微复杂一些。

### Partial

索引类型可以通过映射类型的语法做修改，比如把索引变为可选。

```ts
type Partial<T> = {
    [P in keyof T]?: T[P];
};
```

类型参数 T 为待处理的类型。

通过映射类型的语法构造一个新的索引类型返回，索引 P 是来源于之前的 T 类型的索引，也就是 P in keyof T，索引值的类型也是之前的，也就是 T\[P\]。

这样就实现了把索引类型的索引变为可选的效果：

```ts
type Person = {
    name: 'tony'
    age: 15
}


type PartialRes = Partial<Person>
// {
//   name?: "tony" | undefined;
//   age?: 15 | undefined;
// }
```

### Required

可以把索引变为可选，也同样可以去掉可选，也就是 Required 类型：

```ts
type Required<T> = {
    [P in keyof T]-?: T[P];
};
```

类型参数 T 为待处理的类型。

通过映射类型的语法构造一个新的索引类型，索引取自之前的索引，也就是 P in keyof T，但是要去掉可选，也就是 -?，值的类型也是之前的，就是 T\[P\]。

这样就实现了去掉可选修饰的目的：

```ts
type Person = {
    name?: 'tony'
    age?: 15
}


type RequiredRes = Required<Person>
// {
//   name: "tony";
//   age: 15;
// }
```

### Readonly

同样的方式，也可以添加 readonly 的修饰：

```ts
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
```

类型参数 T 为待处理的类型。

通过映射类型的语法构造一个新的索引类型返回，索引和值的类型都是之前的，也就是 P in keyof T 和 T\[P\]，但是要加上 readonly 的修饰。

这样就实现了加上 readonly 的目的：

```ts
type Person = {
    name: 'tony'
    age: 15
}

type ReadonlyRes = Readonly<Person>
// {
//   readonly name: "tony";
//   readonly age: 15;
// }
```

### Pick

映射类型的语法用于构造新的索引类型，在构造的过程中可以对索引和值做一些修改或过滤。

比如可以用 Pick 实现过滤：

```ts
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
```

类型参数 T 为待处理的类型，类型参数 K 为要过滤出的索引，通过 extends 约束为只能是 T 的索引的子集。

构造新的索引类型返回，索引取自 K，也就是 P in K，值则是它对应的原来的值，也就是 T\[P\]。

这样就实现了过滤的目的：

```ts
type Person = {
    name: 'tony'
    age: 15
}


type PickRes = Pick<Person, 'age'>
// {
//   age: 15;
// }
```

### Record

Record 用于创建索引类型，传入 key 和值的类型：

```ts
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

这里很巧妙的用到了 keyof any，它的结果是 string | number | symbol：

但如果你开启了 keyOfStringsOnly 的编译选项，它就只是 string 了：

用 keyof any 是动态获取的，比直接写死 string | number | symbol 更好。

继续讲 Record 这个类型，它用映射类型的语法创建了新的索引类型，索引来自 K，也就是 P in K，值是传入的 T。

这样就用 K 和 T 构造出了对应的索引类型。

```ts
type RecordRes = Record<'a' | 'b', number>
// {
//   a: number;
//   b: number;
// }
```

当传入的 K 是 string | number | symbol，那么创建的就是有可索引签名的索引类型：

```ts
type RecordRes = Record<string, number>
// {
//   [x: string]: number;
// }
```

### Exclude

当想从一个联合类型中去掉一部分类型时，可以用 Exclude 类型：

```ts
type Exclude<T, U> = T extends U ? never : T;
```

联合类型当作为类型参数出现在条件类型左边时，会被分散成单个类型传入，这叫做分布式条件类型。

所以写法上可以简化， T extends U 就是对每个类型的判断。

过滤掉 U 类型，剩下的类型组成联合类型。也就是取差集。

```ts
type ExcludeRes = Exclude<'a' | 'b' | 'c' | 'd', 'a' | 'b'> // "c" | "d"
```

这里用了分布式条件类型的性质，写法上可以简化。

### Extract

可以过滤掉，自然也可以保留，Exclude 反过来就是 Extract，也就是取交集：

```ts
type Extract<T, U> = T extends U ? T : never;
```

```ts
type ExtractRes = Extract<'a' | 'b' | 'c' | 'd', 'a' | 'b'> // "a" | "b"
```

### Omit

我们知道了 Pick 可以取出索引类型的一部分索引构造成新的索引类型，那反过来就是去掉这部分索引构造成新的索引类型。

可以结合 Exclude 来轻松实现：

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
```

类型参数 T 为待处理的类型，类型参数 K 为索引允许的类型（string | number | symbol 或者 string）。

通过 Pick 取出一部分索引构造成新的索引类型，这里用 Exclude 把 K 对应的索引去掉，把剩下的索引保留。

这样就实现了删除一部分索引的目的：

```ts
type Person = {
    name: 'tony'
    age: 15
}

type OmitRes = Omit<Person, 'age'>
// {
//   name: 'tony';
// }
```

### Awaited

取 Promise 的 ValuType 的高级类型，这个比较常用，ts 也给内置了，就是 Awaited。

```ts
type Awaited<T> =
    T extends null | undefined
        ? T
        : T extends object & { then(onfulfilled: infer F): any }
            ? F extends ((value: infer V, ...args: any) => any)
                ? Awaited<V>
                : never
            : T;
```

类型参数 T 是待处理的类型。

如果 T 是 null 或者 undefined，就返回 T。

如果 T 是对象并且有 then 方法，那就提取 then 的参数，也就是 onfulfilled 函数的类型到 infer 声明的局部变量 F。

继续提取 onfullfilled 函数类型的第一个参数的类型，也就是 Promise 返回的值的类型到 infer 声明的局部变量 V。

递归的处理提取出来的 V，直到不再满足上面的条件。

这样就实现了取出嵌套 Promise 的值的类型的目的:

```ts
type AwaitedRes = Awaited<Promise<Promise<Promise<Promise<number>>>>> // number
```

为什么要提取 then 方法的第一个参数的返回值类型看下 Promise 的结构就明白了：

```ts
new Promise(() => {
    // xxx
}).then((value) => {
});
```

then 第一个参数是 onfullfilled 的回调，从它的第一个参数就能拿到返回的值的类型。

内置的高级类型不再限制必须是 Promise，而是只要对象且有 then 方法就可以，这样更通用了一些。

### NonNullable

NonNullable 就是用于判断是否为非空类型（可以去除联合类型中的 null 或 undefined），也就是不是 null 或者 undefined 的类型的，实现比较简单：

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```

当传入 null 时：

```ts
type NonNullableRes = NonNullable<undefined> // never
```

当传入非空类型时：

```ts
type NonNullableRes = NonNullable<'1' | null> // '1'
```

### Uppercase、Lowercase、Capitalize、Uncapitalize

这四个类型是分别实现大写、小写、首字母大写、去掉首字母大写的。

```ts
type UppercaseRes = Uppercase<'aaaa'> // 'AAAA'

type LowercaseRes = Lowercase<'AAAA'> // 'aaaa'

type CapitalizeRes = Capitalize<'aaaa'> // 'Aaaa'

type UncapitalizeRes = Uncapitalize<'AAAA'> // 'aAAA'
```

它们的源码时这样的：

```ts
type Uppercase<S extends string> = intrinsic;

type Lowercase<S extends string> = intrinsic;

type Capitalize<S extends string> = intrinsic;

type Uncapitalize<S extends string> = intrinsic;
```

啥情况，intrinsic 是啥？

这个 intrinsic 是固有的意思，就像 js 里面的有的方法打印会显示 \[native code\] 一样。这部分类型不是在 ts 里实现的，而是编译过程中由 js 实现的。

我们可以在源码里找到对应的处理代码：

![](_attachment/img/aon3g-tuzo2.png)

其实就是 ts 编译器处理到这几个类型时就直接用 js 给算出来了。

为啥要这样做呢？

因为快啊，解析类型是要处理 AST 的，性能比较差，用 js 直接给算出来那多快呀。

### ThisType

ThisType 的作用是可以在对象字面量中指定 this 的类型。ThisType 不返回转换后的类型，而是通过 ThisType 的泛型参数指定 this 的类型，下面看一个具体的示例：

> 注意：如果你想使用这个工具类型，那么需要开启 noImplicitThis 的 TypeScript 配置。

<iframe src="https://www.typescriptlang.org/play?#code/C4TwDgpgBA8gRgKwgY2AEQgZ2QJwJZjAD2OAPGgDRQCyAfFALxQDeAUFFACYCGw3A-AC4oaANzsoAWwjAAFkU6YhNKADIoAFVl5MG8BHJqatUVAD0ZqTPmKogWjkocnVEAhboG8fQNHqgejMRR6qwBfcVYAMwBXADtUPCIIqW4Aawh4JFRyKjoACk4sZGEUlHRc-EISdOMASmE0PxYJABsZLl5uYSJEQsYuXIA6Hj4oAB9BliCGpuk5BUw2jtQunOweyZtMIZHmMY4cGTCcOOYoHuP+7ipj5etpqACobjWa9WpxANZWZFjMYCh2hC7JRLJObATJsDinYSHAAewgADFQQHCbhQJCtppCJBxJEQAG4QABCIGyMKgETCkjgEBwVE4iNJ5MpOAqdQ4rMc2kwPShUAA1ExOFDTBZ2c4GPRHjRMaynJyQLz+SAhZYZYxxX4pQEURxNYEKsFflyugBGWHiA1ypgAJlNrAN2LxhMyAFYqE69UA"
  border="0"
  frameborder="0"
  height="650"
  width="100%"></iframe>

在上述示例子中，methods 属性的 this 类型为 D & M，在上下文中指代 `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`。

ThisType 工具类型只是提供了一个空的泛型接口，仅可以在对象字面量上下文中被 TypeScript 识别，如下所示：

```ts
interface ThisType<T> {}
```

也就是说该类型的作用相当于任意空接口。

这基本就是全部的内置高级类型了。

## 练习网址

[type-challenges](https://github.com/type-challenges/type-challenges)

[typescript-exercises](https://typescript-exercises.github.io/)

```shell
// https://github.com/ln0y/type-challenges-downloader

npx type-challenges-downloader -p ./type-challenges -w 100
```
