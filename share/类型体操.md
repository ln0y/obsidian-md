---
aliases: []
tags: ['share', 'TypeScript', 'date/2022-08', 'year/2022', 'month/08']
date: 2022-08-03-星期三 10:18:56
update: 2024-05-17-星期五 16:30:28
---

## 前言

### ts 痛点

- 不会写类型，any 一把梭
- 性能慢，构建时间长
- 学习成本高
- 编写类型费时间

### 解决方式

> 不会写类型，any 一把梭

例子:

![](_attachment/Pasted%20image%2020240509183430.png)

如果没写 `any` 会出现一堆类型错误提示，表示 `null` 不兼容当前赋值的类型

![](_attachment/img/3712184dfed2251b5305acdd277f6ace_MD5.png)

可以在 tsconfig 中添加 `"strictNullChecks": false`，关闭 `null` 和 `undefined` 的类型检查

![](_attachment/img/cdbd89598895f815dbbd71fafec1f0c5_MD5.png)

此时 `organizationTree` 已经默认为 `any` 了，不需要再自行断言为 `any`

![](_attachment/img/313b0b84dafa7705301090f4538faf04_MD5.png)

接下来我们可以看到第二个错误，`item` 含有隐式 `any` 类型，就是 `item` 已经推导为 `any` 类型，但是这里的 `any` 可能不是你想要的，你得明确声明类型，即使声明 `any` 也可以

此时可以向 tsconfig 添加 `"noImplicitAny": false`，关闭隐式 any 的检查

![](_attachment/img/6961902cab4a250a8a8c8bcf98cbc585_MD5.png)

现在 `item` 即使是 `any` 也不会有提示了

![](_attachment/img/5519970d91a5818354cf754bcc045f5c_MD5.png)

接口声明和接口返回值中的 `any` 也可以省略了

![](_attachment/img/d8ee4e266e813e043ac257f09b1d88d5_MD5.png)

其实可以一劳永逸的设置 `"strict": false`，目前是 [strict](https://www.typescriptlang.org/tsconfig/#strict) 是以下几条的合并属性，并且会随着版本变动而进行新增或删除，感兴趣可以自行阅读其他几条规则。

![](_attachment/img/347a7c92969a0af7149792c39c51b16e_MD5.png)

针对 tsconfig 的配置，我们可以抽成一个 tsconfig 包进行管理，可以学习 [`@vue/tsconfig`](https://github.com/vuejs/tsconfig#readme) 提供多种配置，只需引入就可以了，这样可以进行统一管理更新及删除属性

![](_attachment/img/cf27ca08b694a9c3c3e5ca78e96b7144_MD5.png)

> [!INFO]+ tsconfig 提议
> 例如：如果对 ts 不熟悉想使用宽松的配置可以引入 `@vesync/tsconfig/tsconfig.loose.json`，熟悉 ts 或者开发组件或者库的时候可以使用 `@vesync/tsconfig/tsconfig.recommended.json`，严格的可以采用 `@vesync/tsconfig/tsconfig.strict.json`

> 性能慢，构建时间长

对于大型复杂项目，可以配置 `Project Reference`，针对不同子模块创建各自的 tsconfig.json 放各自的编译配置。注意这里要加一个 `composite: true`，然后在根目录的 tsconfig.json 里加上一个 `references` 的配置，引入不同的子模块 tsconfig.json，这样可以对不同的独立模块进行编译缓存

![|800](_attachment/img/fc7ec60416fe426edf0c94d900b64371_MD5.png)

![|800](_attachment/img/08fab4a5dc7c8c70231ef152a3b2025b_MD5.png)

或者可以替换其他编译插件，例如 [esbuild](https://esbuild.github.io/)、[swc](https://swc.rs/)，这些工具会跳过类型检查环节直接抹除类型代码，提升构建速度。

> 学习成本高

ts 的类型系统确实很复杂，可以从基础开始，逐渐深入。首先熟悉基本的类型注解，然后再逐渐学习接口（Interfaces）、泛型（Generics）、枚举（Enums）等高级特性。配合 `"strict": false` 从 anyscript 开始接触。

即使你不写任何类型，也可以享受其他用 typescript 编写的第三方库的类型提示。

例如 echarts，echarts options 拥有大量的属性字段，查看字段枚举值除了可以直接翻文档外还可以借由 typescript 做提示进行快速输入

![](_attachment/img/9b162abc0072529c1872de2f0bfbea7c_MD5.png)

![](_attachment/img/6befde811f0fcf6c994d6b04ec3e6f1c_MD5.png)

> 编写类型费时间

对于业务代码如果编写大量的精确的类型，花费的时间和收入不成正比，可以适当采用 any 略过，或者编写简单的类型推断对于业务代码也已足够用。

[Typescript Playground](https://www.typescriptlang.org/play/?#code/FAMwrgdgxgLglgewgAgLYFMBOBzdAeAFWXQA8Z0IATAZ2QQCMArdWAPgAoHGBGALmQIAaOkwBM-AgEoJyAN7Bki5JnQwwmFPKXbkAOn1dughTsX7dXUce0BfYHeAB6R8hgBPAA7pkAa3RvaAF5ffwQQZABDCDcnF3cvZDhqAHkmFhhCVmRgolJyKloAJRYETEo8PwDhKLcsgH4BZH4IdAA3LFjXT28MHHwhZABVLOD5Zx0AbQBpRJRKsMaAHxC3BcGAXX4ZvIoaFbXkBsHp9abkbbJd2nnwogaCE7OW9sxOmwBuYE7x+J6sXDwADFhABlEbIZKoOAZYH7cJg5AAMmQIK+43A0HgSDQ-3wUCQ1BgAmE+IghKGHEM-CSqWYsEywks1JSaXpw2kOL6hGEwzknW0KjUGj541MZgMTCM-LF5ksxlFSjs4wcpPJWEw2U5uHYski-G4yBswgALJIvqqieRycFetrdRF9cJ6PxRIbhLrncgAOQAIS9hrNqoQABt0LpgwhsOwrTBdBEzQqxToAHp1YBB0PhyPR9CE3T0BMuJOmVNfIA)

<iframe src="https://www.typescriptlang.org/play/?#code/FAMwrgdgxgLglgewgAgLYFMBOBzdAeAFWXQA8Z0IATAZ2QQCMArdWAPgAoHGBGALmQIAaOkwBM-AgEoJyAN7Bki5JnQwwmFPKXbkAOn1dughTsX7dXUce0BfYHeAB6R8hgBPAA7pkAa3RvaAF5ffwQQZABDCDcnF3cvZDhqAHkmFhhCVmRgolJyKloAJRYETEo8PwDhKLcsgH4BZH4IdAA3LFjXT28MHHwhZABVLOD5Zx0AbQBpRJRKsMaAHxC3BcGAXX4ZvIoaFbXkBsHp9abkbbJd2nnwogaCE7OW9sxOmwBuYE7x+J6sXDwADFhABlEbIZKoOAZYH7cJg5AAMmQIK+43A0HgSDQ-3wUCQ1BgAmE+IghKGHEM-CSqWYsEywks1JSaXpw2kOL6hGEwzknW0KjUGj541MZgMTCM-LF5ksxlFSjs4wcpPJWEw2U5uHYski-G4yBswgALJIvqqieRycFetrdRF9cJ6PxRIbhLrncgAOQAIS9hrNqoQABt0LpgwhsOwrTBdBEzQqxToAHp1YBB0PhyPR9CE3T0BMuJOmVNfIA"
  border="0"
  frameborder="0"
  height="700"
  width="100%"></iframe>

### ts 优点

- 快速重命名
  vscode 中使用 F2 可以进行重命名，比搜索效率更高，更安全
  ![](_attachment/Pasted%20image%2020240513154814.png)

- 快速发现未导入的变量
  ![](_attachment/Pasted%20image%2020240507145114.png)
  ![](_attachment/Pasted%20image%2020240507145021.png)

- 快速导入
  ![](_attachment/img/7942f13c3da23862cafbaa9591af5f1a_MD5.png)

- 变量函数跳转（支持路径别名，例 `@/`）
  ![](_attachment/Pasted%20image%2020240513143058.png)
  ![](_attachment/img/55471d87acf2584510828d5d6b8a6fca_MD5.png)

- 变量函数引用次数及位置
  ![](_attachment/img/0d3bc6bcc54dee25cb59324f2d48339f_MD5.png)

  组件可以通过 ts 文件统一导出，方便查看组件的引用，对于组件的改动影响范围有预期

  ![](_attachment/Pasted%20image%2020240514151048.png)

- 发现未使用的变量或函数
  未使用的变量会标灰（eslint 也能检测）

  ![](_attachment/img/407260ea715f1d1db35975b196a2661a_MD5.png)

  目前 pm 项目中 eslint 警告 90% 都是定义未使用的变量

  ![](_attachment/img/52125d1170ebad633986ccc7652cedc7_MD5.png)

- 自动类型提示
- 提示潜在的类型问题
- 代替文档（部分三方库）
  目前市面上有些三方库并未提供相应的文档说明，如 [unbuild](https://github.com/unjs/unbuild)、[@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/blob/main/packages/plugin-vue/README.md)、[vite-plugin-preload](https://github.com/jarlef/vite-plugin-preload/tree/main/#readme)

## 进入主题

类型系统不止 TypeScript 有，别的语言 Java、C++ 等都有，为什么 TypeScript 的类型编程被叫做类型体操，而其他语言没有呢？

TypeScript 给 JavaScript 增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。

它并没有改变 JavaScript 的语法，只是在 JS 的基础上添加了类型语法，所以被叫做 JavaScript 的超集。

JavaScript 的标准在不断的发展，TypeScript 的类型系统也在不断完善，因为“超集”的设计理念，这两者可以很好的融合在一起，是不会有冲突的。

静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类：

## 简单类型系统

变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时会报错。

这是最基础的类型系统，能保证类型安全，但有些死板。

比如一个 add 函数既可以做整数加法、又可以做浮点数加法，却需要声明两个函数：

```cpp
int add(int a, int b) {
  return a + b;
}

double add(double a, double b) {
  return a + b;
}
```

这个问题的解决思路很容易想到：如果类型能传参数就好了，传入 `int` 就是整数加法，传入 `double` 就是浮点数加法。

所以，就有了第二种类型系统。

## 支持泛型的类型系统

泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做 `类型参数`。

它给类型系统增加了一些灵活性，在整体比较固定，部分变量的类型有变化的情况下，可以减少很多重复代码。

比如上面的 `add` 函数，有了泛型之后就可以这样写：

```cpp
T add<T>(T a, T b) {
  return a + b;
}

add(1,2);
add(1.111, 2.2222);
```

**声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。**

Java 就是这种类型系统。

但是，这种类型系统的灵活性对于 JavaScript 来说还不够，因为 JavaScript 太过灵活了。

比如，在 Java 里，对象都是由类 new 出来的，你不能凭空创建对象，但是 JavaScript 却可以，它支持对象字面量。

那如果是一个返回对象某个属性值的函数，类型该怎么写呢？

```ts
function getPropValue<T>(obj: T, key): key对应的属性值类型 {
  return obj[key]
}
```

好像拿到了 `T`，也不能拿到它的属性和属性值，如果能对类型参数 T 做一些逻辑处理就好了。

所以，就有了第三种类型系统。

## 支持类型编程的类型系统

在 Java 里面，拿到了对象的类型就能找到它的类，进一步拿到各种信息，所以类型系统支持泛型就足够了。

但是在 JavaScript 里面，对象可以字面量的方式创建，还可以灵活的增删属性，拿到对象并不能确定什么，所以要支持对传入的类型参数做进一步的处理。

**对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。**

比如上面那个 getProps 的函数，类型可以这样写：

```ts
function getPropValue<T extends object, Key extends keyof T>(obj: T, key: Key): T[Key] {
  return obj[key]
}
```

这里的 keyof T、T\[Key\] 就是对类型参数 T 的类型运算。

TypeScript 的类型系统就是第三种，支持对类型参数做各种逻辑处理，可以写很复杂的类型逻辑。

**类型逻辑可以多复杂？**

类型逻辑是对类型参数的各种处理，可以实现很多强大的功能：

比如这个 ParseQueryString 的类型：

[Typescript Playground](https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4QIoFcIJAZWAgSwDsBzAHgBUoIAPYCIgEySiX2JID4oBeKK2vSYsABgBIA3sQBmWWIjgBbAL4AySTLkAlCG2UiAUFCgB+KAFksJCPARKkZWyltLHCxZwA085GkzY8QlIyHTZOTiMoAC4fZ3dKCINQSFibeIE6BmZWdlJuPgyhbPEpIlkEKABpZR4NMrkANX1TKB0AYwB7BEYySu8G7hiJZQMk8GhLBGsXRQcYAEZqTOEoDoAjACsINuBvGAAmJaKWda2d-KgJSIBtSqhiKABrCBAO6Vh5gF0Yu8Eslmer3eB0ixjM1wWt0+3gAdHCABQHKFHf5QOBEEDXT4tJGVbExCH7KGfACUn1B0Q+UIMyigqkuNwa9yITxeb1ghzgLCZfxWgPZCxaRAgADc5DEGt8OddJTTRskJlYIABJIgoBDAAgdNUJXj8FErU7bYAtCRQW7M1lA-hSybWVXqzXahwUKHcWkxCjy8ZQehsPXXSJ2lVqrBOnVONJ2RRkADkcB481j4U8QaVDrDWojiBQGCwuFy5HjieTXjTUxDjqzcxzfnzgQ4cYT81Uax4+1UbR4AGZS6njMGMxrq25fHmAoWm4nVAmO22O13eyny-bQ8PnaPc-4C0Ei83W+2Dwue6WDOSgA)

<iframe src="https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4QIoFcIJAZWAgSwDsBzAHgBUoIAPYCIgEySiX2JID4oBeKK2vSYsABgBIA3sQBmWWIjgBbAL4AySTLkAlCG2UiAUFCgB+KAFksJCPARKkZWyltLHCxZwA085GkzY8QlIyHTZOTiMoAC4fZ3dKCINQSFibeIE6BmZWdlJuPgyhbPEpIlkEKABpZR4NMrkANX1TKB0AYwB7BEYySu8G7hiJZQMk8GhLBGsXRQcYAEZqTOEoDoAjACsINuBvGAAmJaKWda2d-KgJSIBtSqhiKABrCBAO6Vh5gF0Yu8Eslmer3eB0ixjM1wWt0+3gAdHCABQHKFHf5QOBEEDXT4tJGVbExCH7KGfACUn1B0Q+UIMyigqkuNwa9yITxeb1ghzgLCZfxWgPZCxaRAgADc5DEGt8OddJTTRskJlYIABJIgoBDAAgdNUJXj8FErU7bYAtCRQW7M1lA-hSybWVXqzXahwUKHcWkxCjy8ZQehsPXXSJ2lVqrBOnVONJ2RRkADkcB481j4U8QaVDrDWojiBQGCwuFy5HjieTXjTUxDjqzcxzfnzgQ4cYT81Uax4+1UbR4AGZS6njMGMxrq25fHmAoWm4nVAmO22O13eyny-bQ8PnaPc-4C0Ei83W+2Dwue6WDOSgA"
  border="0"
  frameborder="0"
  height="700"
  width="100%"></iframe>

它可以对传入的字符串的类型参数做解析，返回解析以后的结果。

如果是 Java 的只支持泛型的类型系统可以做到么？明显不能。但是 TypeScript 的类型系统就可以，因为它可以对泛型（类型参数）做各种逻辑处理。

**TypeScript 的类型系统是 `图灵完备` 的，也就是能描述各种可计算逻辑。简单点来理解就是循环、条件等各种 JS 里面有的语法它都有，JS 能写的逻辑它都能写。**

对类型参数的编程是 TypeScript 类型系统最强大的部分，可以实现各种复杂的类型计算逻辑，是它的优点。但同时也被认为是它的缺点，因为除了业务逻辑外还要写很多类型逻辑。

不过，这种复杂度是不可避免的，因为 JS 本身足够灵活，要准确定义类型那类型系统必然也要设计的足够灵活。

但是很多类型编程的逻辑写起来比较复杂，因此被戏称为类型体操。

## TypeScript 类型系统中的类型

静态类型系统的目的是把类型检查从运行时提前到编译时，那 TS 类型系统中肯定要把 JS 的运行时类型拿过来，也就是 `number`、`boolean`、`string`、`object`、`bigint`、`symbol`、`undefined`、`null` 这些拆箱类型，还有就是它们的装箱类型 `Number`、`Boolean`、`String`、`Object`、`Symbol`（不建议使用）。

这些很容易理解，给 JS 添加静态类型，总没有必要重新造一套基础类型吧，直接复用 JS 的基础类型就行。

复合类型方面，JS 有 class、Array，这些 TypeScript 类型系统也都支持，但是又多加了三种类型：元组（Tuple）、接口（Interface）、枚举（Enum）。

### 元组

`元组（Tuple）` 就是元素个数和类型固定的数组类型：

```ts
type Tuple = [number, string]
```

### 接口

`接口（Interface）` 可以描述函数、对象、构造器的结构：

对象：

```ts
interface IPerson {
  name: string
  age: number
}

class Person implements IPerson {
  name: string
  age: number
}

const obj: IPerson = {
  name: 'tony',
  age: 18,
}
```

函数：

```ts
interface SayHello {
  (name: string): string
}

const func: SayHello = (name: string) => {
  return 'hello,' + name
}
```

构造器：

```ts
interface PersonConstructor {
  new (name: string, age: number): IPerson
}

function createPerson(ctor: PersonConstructor): IPerson {
  return new ctor('tony', 18)
}
```

对象类型、class 类型在 TypeScript 里也叫做索引类型，也就是索引了多个元素的类型的意思。对象可以动态添加属性，如果不知道会有什么属性，可以用可索引签名：

```ts
interface IPerson {
  [prop: string]: string | number
}
const obj: IPerson = {}
obj.name = 'tony'
obj.age = 18
```

总之，**接口可以用来描述函数、构造器、索引类型（对象、class、数组）等复合类型**。

### 枚举

`枚举（Enum）` 是一系列值的复合：

```ts
enum Transpiler {
  Babel = 'babel',
  Postcss = 'postcss',
  Terser = 'terser',
  Prettier = 'prettier',
  TypeScriptCompiler = 'tsc',
}

const transpiler = Transpiler.TypeScriptCompiler
```

此外，TypeScript 还支持 `字面量类型`，也就是类似 `1111`、`'aaaa'`、`{ a: 1}` 这种值也可以做为类型。

其中，字符串的字面量类型有两种，一种是普通的字符串字面量，比如 `'aaa'`，另一种是模版字面量，比如 `aaa${string}`，它的意思是以 `aaa` 开头，后面是任意 `string` 的字符串字面量类型。

还有四种特殊的类型：`void`、`never`、`any`、`unknown`：

- **never** 代表不可达，比如函数抛异常的时候，返回值就是 never。
- **void** 代表空，可以是 undefined 或 never。
- **any** 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。
- **unknown** 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。

这些就是 TypeScript 类型系统中的全部类型了，大部分是从 JS 中迁移过来的，比如基础类型、`Array`、`class` 等，也添加了一些类型，比如 枚举（enum）、接口（interface）、元组等，还支持了字面量类型和 `void`、`never`、`any`、`unknown` 的特殊类型。

### 类型的装饰

除了描述类型的结构外，TypeScript 的类型系统还支持描述类型的属性，比如是否可选，是否只读等：

```ts
interface IPerson {
  readonly name: string
  age?: number
}

type tuple = [string, number?]
```

## 类型别名

类型别名可以说是 TypeScript 类型编程中最重要的一个功能，从一个简单的函数类型别名，到让你眼花缭乱的类型体操，都离不开类型别名。虽然很重要，但它的使用却并不复杂：

```ts
type A = string
```

我们通过 `type` 关键字声明了一个类型别名 `A` ，同时它的类型等价于 `string` 类型。类型别名的作用主要是对一组类型或一个特定类型结构进行封装，以便于在其它地方进行复用。

比如抽离一组联合类型：

```ts
type StatusCode = 200 | 301 | 400 | 500 | 502
type PossibleDataTypes = string | number | (() => unknown)

const status: StatusCode = 502
```

抽离一个函数类型：

```ts
type Handler = (e: Event) => void

const clickHandler: Handler = e => {}
const moveHandler: Handler = e => {}
const dragHandler: Handler = e => {}
```

声明一个对象类型，就像接口那样：

```ts
type ObjType = {
  name: string
  age: number
}
```

看起来类型别名真的非常简单，不就是声明了一个变量让类型声明更简洁和易于拆分吗？如果真的只是把它作为类型别名，用来进行特定类型的抽离封装，那的确很简单。然而，类型别名还能作为工具类型。**工具类同样基于类型别名，只是多了个泛型**。

在类型别名中，类型别名可以这么声明自己能够接受泛型（我称之为泛型坑位）。一旦接受了泛型，我们就叫它工具类型：

```ts
type Factory<T> = T | number | string
```

虽然现在类型别名摇身一变成了工具类型，但它的基本功能仍然是创建类型，只不过工具类型能够接受泛型参数，实现 **更灵活的类型创建功能**。从这个角度看，工具类型就像一个函数一样，泛型是入参，内部逻辑基于入参进行某些操作，再返回一个新的类型。比如在上面这个工具类型中，我们就简单接受了一个泛型，然后把它作为联合类型的一个成员，返回了这个联合类型。

```ts
const foo: Factory<boolean> = true
```

当然，我们一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型别名：

```ts
type FactoryWithBool = Factory<boolean>

const foo: FactoryWithBool = true
```

同时，泛型参数的名称（上面的 `T` ）也不是固定的。通常我们使用大写的 `T / K / U / V / M / O`…这种形式。如果为了可读性考虑，我们也可以写成大驼峰形式（即在驼峰命名的基础上，首字母也大写）的名称，比如：

```ts
type Factory<NewType> = NewType | number | string
```

声明一个简单、有实际意义的工具类型：

```ts
type MaybeNull<T> = T | null
```

这个工具类型会接受一个类型，并返回一个包括 `null` 的联合类型。这样一来，在实际使用时就可以确保你处理了可能为空值的属性读取与方法调用：

```ts
type MaybeNull<T> = T | null

function process(input: MaybeNull<{ handler: () => {} }>) {
  input?.handler()
}
```

类似的还有 `MaybePromise`、`MaybeArray`。这也是我们在日常开发中最常使用的一类工具类型：

```ts
type MaybeArray<T> = T | T[]

function ensureArray<T>(input: MaybeArray<T>): T[] {
  return Array.isArray(input) ? input : [input]
}
```

另外，类型别名中可以接受任意个泛型，以及为泛型指定约束、默认值等。

总之，对于工具类型来说，它的主要意义是 **基于传入的泛型进行各种类型操作**，得到一个新的类型。而这个类型操作的指代就非常非常广泛了，甚至说类型编程的大半难度都在这儿。

## 联合类型与交叉类型

联合类型还有一个和它有点像的孪生兄弟：**交叉类型**。它和联合类型的使用位置一样，只不过符号是 `&`，即按位与运算符。

实际上，正如联合类型的符号是 `|`，它代表了按位或，即只需要符合联合类型中的一个类型，既可以认为实现了这个联合类型，如 `A | B`，只需要实现 A 或 B 即可。

而代表着按位与的 `&` 则不同，你需要符合这里的所有类型，才可以说实现了这个交叉类型，即 `A & B`，**需要同时满足 A 与 B 两个类型** 才行。

我们声明一个交叉类型：

```ts
interface NameStruct {
  name: string
}

interface AgeStruct {
  age: number
}

type ProfileStruct = NameStruct & AgeStruct

const profile: ProfileStruct = {
  name: 'tony',
  age: 18,
}
```

很明显这里的 `profile` 对象需要同时符合这两个对象的结构。从另外一个角度来看，`ProfileStruct` 其实就是一个新的，同时包含 `NameStruct` 和 `AgeStruct` 两个接口所有属性的类型。这里是对于对象类型的合并，那对于原始类型呢？

```ts
type StrAndNum = string & number // never
```

我们可以看到，它竟然变成 `never` 了！看起来很奇怪，但想想我们前面给出的定义，新的类型会同时符合交叉类型的所有成员，存在既是 `string` 又是 `number` 的类型吗？当然不。实际上，这也是 `never` 这一 `BottomType` 的实际意义之一，描述 **根本不存在的类型** 嘛。

对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并：

```ts
type Struct1 = {
  primitiveProp: string
  objectProp: {
    name: string
  }
}

type Struct2 = {
  primitiveProp: number
  objectProp: {
    age: number
  }
}

type Composed = Struct1 & Struct2

type PrimitivePropType = Composed['primitiveProp'] // never
type ObjectPropType = Composed['objectProp'] // { name: string; age: number; }
```

如果是两个联合类型组成的交叉类型呢？其实还是类似的思路，既然只需要实现一个联合类型成员就能认为是实现了这个联合类型，那么各实现两边联合类型中的一个就行了，也就是两边联合类型的交集：

```ts
type UnionIntersection1 = (1 | 2 | 3) & (1 | 2) // 1 | 2
type UnionIntersection2 = (string | number | symbol) & string // string
```

总结一下交叉类型和联合类型的区别就是，联合类型只需要符合成员之一即可（`||`），而交叉类型需要严格符合每一位成员（`&&`）。

## 索引类型

索引类型指的不是某一个特定的类型工具，它其实包含三个部分：**索引签名类型**、**索引类型查询** 与 **索引类型访问**。目前很多社区的学习教程并没有这一点进行说明，实际上这三者都是独立的类型工具。唯一共同点是，**它们都通过索引的形式来进行类型操作**，但索引签名类型是 **声明**，后两者则是 **读取**。接下来，我们来依次介绍三个部分。

### 索引签名类型

索引签名类型主要指的是在接口或类型别名中，通过以下语法来 **快速声明一个键值类型一致的类型结构**：

```ts
interface AllStringTypes {
  [key: string]: string
}

type AllStringTypes = {
  [key: string]: string
}
```

这时，即使你还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 `string` 类型：

```ts
interface AllStringTypes {
  [key: string]: string
}

type PropType1 = AllStringTypes['tony'] // string
type PropType2 = AllStringTypes['599'] // string
```

在这个例子中我们声明的键的类型为 string（`[key: string]`），这也意味着在实现这个类型结构的变量中 **只能声明字符串类型的键**：

```ts
interface AllStringTypes {
  [key: string]: string
}

const foo: AllStringTypes = {
  tony: '599',
}
```

但由于 JavaScript 中，对于 `obj[prop]` 形式的访问会将 **数字索引访问转换为字符串索引访问**，也就是说， `obj[599]` 和 `obj['599']` 的效果是一致的。因此，在字符串索引签名类型中我们仍然可以声明数字类型的键。类似的，symbol 类型也是如此：

```ts
const foo: AllStringTypes = {
  tony: '599',
  599: 'tony',
  [Symbol('ddd')]: 'symbol',
}
```

索引签名类型也可以和具体的键值对类型声明并存，但这时这些具体的键值类型也需要符合索引签名类型的声明：

```ts
interface AllStringTypes {
  // 类型“number”的属性“propA”不能赋给“string”索引类型“boolean”。
  propA: number
  [key: string]: boolean
}
```

这里的符合即指子类型，因此自然也包括联合类型：

```ts
interface StringOrBooleanTypes {
  propA: number
  propB: boolean
  [key: string]: number | boolean
}
```

> [!INFO]+ 注
> 如果你希望只有 `propB` 是 `boolean`，其他都是 value 都是 `number` 那么可以使用联合类型
>
> ```ts
> type StringOrBooleanTypes =
>   | {
>       propA: number
>       [key: string]: number
>     }
>   | {
>       propB: boolean
>     }
> ```

索引签名类型的一个常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 `any` 的索引签名类型，以此来暂时支持 **对类型未明确属性的访问**，并在后续一点点补全类型：

```ts
interface AnyTypeHere {
  [key: string]: any
}

const foo: AnyTypeHere['tony'] = 'any value'
```

### 索引类型查询

刚才我们已经提到了索引类型查询，也就是 `keyof` 操作符。严谨地说，它可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。注意，**这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量**。

```ts
interface Foo {
  tony: 1
  599: 2
}

type FooKeys = keyof Foo // "tony" | 599
```

> [!INFO]+ 注
> 在这里 `FooKeys` 会显示 `keyof Foo` 没有显示 `"tony" | 599`，这是 ts 做了性能优化，ts 只有类型被用到的时候才会做类型计算，因此可以通过 `extends` 强制触发计算
>
> ```ts
> type forceKeyof<T, U = keyof T> = U extends any ? U : never
> type FooKeys = forceKeyof\<Foo> // "tony"  |  599
> ```

如果觉得不太好理解，我们可以写段伪代码来模拟 **“从键名到联合类型”** 的过程。

```ts
type FooKeys = Object.keys(Foo).join(" | ");
```

除了应用在已知的对象类型结构上以外，你还可以直接 `keyof any` 来生产一个联合类型，它会由所有可用作对象键值的类型组成：`string | number | symbol`。也就是说，它是由无数字面量类型组成的，由此我们可以知道， **keyof 的产物必定是一个联合类型**。

### 索引类型访问

在 JavaScript 中我们可以通过 `obj[expression]` 的方式来动态访问一个对象属性（即计算属性），expression 表达式会先被执行，然后使用返回值来访问属性。而 TypeScript 中我们也可以通过类似的方式，只不过这里的 expression 要换成类型。接下来，我们来看个例子：

```ts
interface NumberRecord {
  [key: string]: number
}

type PropType = NumberRecord[string] // number
```

这里，我们使用 `string` 这个类型来访问 `NumberRecord`。由于其内部声明了数字类型的索引签名，这里访问到的结果即是 `number` 类型。注意，其访问方式与返回值均是类型。

更直观的例子是通过字面量类型来进行索引类型访问：

```ts
interface Foo {
  propA: number
  propB: boolean
}

type PropAType = Foo['propA'] // number
type PropBType = Foo['propB'] // boolean
```

看起来这里就是普通的值访问，但实际上这里的 `'propA'` 和 `'propB'` 都是 **字符串字面量类型**，**而不是一个 JavaScript 字符串值**。索引类型查询的本质其实就是，**通过键的字面量类型（`'propA'`）访问这个键对应的键值类型（`number`）**。

看到这你肯定会想到，上面的 `keyof` 操作符能一次性获取这个对象所有的键的字面量类型，是否能用在这里？当然，这可是 TypeScript 啊。

```ts
interface Foo {
  propA: number
  propB: boolean
  propC: string
}

type PropTypeUnion = Foo[keyof Foo] // string | number | boolean
```

使用字面量联合类型进行索引类型访问时，其结果就是将联合类型每个分支对应的类型进行访问后的结果，重新组装成联合类型。**索引类型查询、索引类型访问通常会和映射类型一起搭配使用**，前两者负责访问键，而映射类型在其基础上访问键值类型，我们在下面一个部分就会讲到。

注意，在未声明索引签名类型的情况下，我们不能使用 `NumberRecord[string]` 这种原始类型的访问方式，而只能通过键名的字面量类型来进行访问。

```ts
interface Foo {
  propA: number
}

// 类型“Foo”没有匹配的类型“string”的索引签名。
type PropAType = Foo[string]
```

索引类型的最佳拍档之一就是映射类型，同时映射类型也是类型编程中常用的一个手段。

## type 与 interface

### 相似处

#### 1. 都可以描述 `Object` 和 `Function`

两者都可以用来描述对象或函数,但语法不同:

**Type**

```ts
type Point = {
  x: number
  y: number
}

type SetPoint = (x: number, y: number) => void
```

**Interface**

```ts
interface Point {
  x: number
  y: number
}

interface SetPoint {
  (x: number, y: number): void
}
```

#### 2. 二者都可以被继承

`interface` 和 `type` 都可以继承。

另一个值得注意的是，接口和类型别名并不互斥。类型别名可以继承接口，反之亦然。只是在实现形式上，稍微有些差别。

**interface 继承 interface**

```ts
interface Person {
  name: string
}

interface Student extends Person {
  stuNo: number
}
```

**interface 继承 type**

```ts
type Person = {
  name: string
}

interface Student extends Person {
  stuNo: number
}
```

**type 继承 type**

```ts
type Person = {
  name: string
}

type Student = Person & { stuNo: number }
```

**type 继承 interface**

```ts
interface Person {
  name: string
}

type Student = Person & { stuNo: number }
```

#### 3. 实现 implements

类可以实现 `interface` 以及 `type`(除联合类型外)

```ts
interface ICat {
  setName(name: string): void
}

class Cat implements ICat {
  setName(name: string): void {
    // todo
  }
}

// type
type ICat = {
  setName(name: string): void
}

class Cat implements ICat {
  setName(name: string): void {
    // todo
  }
}
```

上面提到了特殊情况，`类无法实现联合类型`, 是什么意思呢？

```ts
type Person = { name: string } | { setName(name: string): void }

// 无法对联合类型Person进行实现
// error: A class can only implement an object type or intersection of object types with statically known members.
class Student implements Person {
  name = '张三'
  setName(name: string): void {
    // todo
  }
}
```

### 二者区别

#### 1. 定义基本类型别名

`type` 可以定义 **基本类型别名**, 但是 `interface` 无法定义,如：

```ts
type userName = string
type stuNo = number
...
```

#### 2. 声明联合类型

`type` 可以声明 **联合类型**, 例如：

```ts
type Student = { stuNo: number } | { classId: number }
```

#### 3. 声明元组

type 可以申明 **元组类型**：

```ts
type Data = [number, string]
```

以上都是 `type` 能做到， 而 `interface` 做不到的， 接下来聊聊 `type` 做不到的

#### 4. 声明合并

如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为 **声明合并**， 例如：

```ts
interface Person {
  name: string
}
interface Person {
  age: number
}

let user: Person = {
  name: 'Tolu',
  age: 0,
}
```

这种情况下，如果是 `type` 的话，重复使用 `Person` 是会报错的：

```ts
type Person = { name: string }

// Error: 标识符“Person”重复。ts(2300)
type Person = { age: number }
```

#### 5. 索引签名问题

如果你经常使用 TypeScript, 一定遇到过相似的错误：

> Type 'xxx' is not assignable to type 'yyy'
>
> Index signature is missing in type 'xxx'.

看个例子来理解问题：

```ts
interface propType {
  [key: string]: string
}

let props: propType

type dataType = {
  title: string
}
interface dataType1 {
  title: string
}
const data: dataType = { title: '订单页面' }
const data1: dataType1 = { title: '订单页面' }
props = data
// Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名
props = data1
```

我们发现 `dataType` 和 `dataType1` 对应的类型一样，但是 `interface` 定义的就赋值失败，是什么原因呢？ stack overflow 上找到了一个相似的问题：

[stackoverflow](https://stackoverflow.com/questions/64970414/typescript-assigning-an-interface-or-a-type-to-a-recordstring-string)

<iframe src="https://stackoverflow.com/questions/64970414/typescript-assigning-an-interface-or-a-type-to-a-recordstring-string"
  border="0"
  frameborder="0"
  height="650"
  width="100%"></iframe>

翻译过来的大致意思就是：

> `Record<string,string>` 与 `{[key:string]：string}` 相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从 `exampleType` 到 `Record<string,string>` 的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。
>
> 相反，**在你使用 interface 去声明变量时，它们在那一刻类型并不是最终的类型**。由于 interfac 可以进行 **声明合并**，所以总有可能将新成员添加到同一个 interface 定义的类型上。

再结合 👆`第 4点 声明合并 ` 的讲解, 这样就很好理解了。 就是说 `interface` 定义的类型是不确定的， 后面再来一个：

```ts
interface propType {
  title: number
}
```

这样 `propType` 类型就被改变了。

### 建议

很多人更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而这里更推荐的方式是，interface 用来描述 **对象、类的结构**，而类型别名用来 **将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型**。但大部分场景下接口结构都可以被类型别名所取代，因此，只要你觉得统一使用类型别名让你觉得更整齐，也没什么问题

## 类型守卫

类型收窄和类型守卫很容易混为一谈，他两密切相关，但是概念和侧重点不同。类型收窄指的是任何减少类型可能性的过程，这可以通过类型守卫来实现，但不限于此。类型收窄可以通过条件检查、类型断言、控制流分析等多种方式实现，并且是 TypeScript 类型系统中的一个核心概念。其目的是让编译器能够更精确地知道在某个特定的代码块中变量的类型。

类型守卫则是实现类型收窄的一种具体方式。它是一种运行时检查，可以让 `TypeScript` 编译器在某个作用域中识别出一个更具体的类型。类型守卫通常是一些表达式或函数，它们返回一个布尔值，用于检查某个变量是否为特定的类型或是否满足某个类型断言。

总结来说，类型收窄是指在代码的某个流程中，通过某些手段减少变量的可能类型，而类型守卫则是实现类型收窄的一种机制。类型守卫通常被用作类型收窄的手段之一。

### typeof 类型守卫

使用 `typeof` 操作符可以检查一个变量是否为 JavaScript 的七种原始类型之一（`number、string、boolean、bigint、symbol、undefined、object`）。

```ts
function padLeft(value: string, padding: string | number) {
  // typeof 类型守卫
  if (typeof padding === 'number') {
    return new Array(padding + 1).join(' ') + value
  }
  if (typeof padding === 'string') {
    return padding + value
  }
  throw new Error(`Expected string or number, got '${padding}'.`)
}
```

这里可能很多人会比较疑惑，`typeof` 这不是 Js 里的么？这里需要区分下，ts 类型编程中的关键字和 ts 中的关键字还有不一样的，包括后面要说到的 `instanceof` 和 `in`

#### JavaScript 中的 typeof

在 JavaScript 中，`typeof` 是一个操作符，用于获取一个变量的基础类型。它返回一个表示变量数据类型的字符串。

```js
console.log(typeof 'hello') // "string"
console.log(typeof 42) // "number"
console.log(typeof true) // "boolean"
console.log(typeof undefined) // "undefined"
console.log(typeof {}) // "object"
console.log(typeof function () {}) // "function"
console.log(typeof Symbol('sym')) // "symbol"
```

JavaScript 中的 `typeof` 返回的类型有："`number`", "`string`", "`boolean`", "`undefined`", "`object`", "`function`", 和 "`symbol`"。注意 `null` 会被错误地认为是 "`object`" 类型，这是 JavaScript 历史遗留的一个 bug。

#### TypeScript 中的 typeof 类型守卫

在 TypeScript 中，`typeof` 不仅可以用在运行时代码中判断变量类型，还可以用作类型守卫和获取类型。当用在类型守卫上时，`typeof` 会被 TypeScript 的类型检查器识别，并在类型流程控制时进行类型收窄。

在这个上下文中，typeof 可以识别两种形式：一种是在 `if` 语句中作为类型断言使用，另一种是在类型别名中获取类型使用。

```ts
const person = { name: 'Nealyang', age: '18' }
type Kevin = typeof person

// type Kevin = {
//   name: string;
//   age: string;
// }

function identity<T>(arg: T): T {
  return arg
}

type result = typeof identity
// type result = <T>(arg: T) => T
```

### instanceof 类型守卫

`instanceof` 操作符用于类的实例，它检查一个实例是否属于某个类。

```ts
class Bird {
  fly() {
    console.log('Flying')
  }
}

class Fish {
  swim() {
    console.log('Swimming')
  }
}

function move(pet: Bird | Fish) {
  // instanceof 类型守卫
  if (pet instanceof Bird) {
    pet.fly()
  } else if (pet instanceof Fish) {
    pet.swim()
  }
}

const myBird = new Bird()
const myFish = new Fish()
move(myBird)
move(myFish)
```

### in 类型守卫

使用 `in` 操作符可以检查一个对象是否拥有某个特定的属性。

```ts
function move(pet: Bird | Fish) {
  // in 类型守卫
  if ('fly' in pet) {
    pet.fly()
  } else {
    pet.swim()
  }
}
```

### 自定义类型守卫

自定义类型守卫通常是通过定义一个函数来实现，这个函数返回一个类型谓词，形式为 `parameterName is Type`。

假设有这么一个字段，它可能字符串也可能是数字：

```ts
type numOrStrProp = number | string
const isString = (arg: unknown): boolean => typeof arg === 'string'
function useIt(numOrStr: number | string) {
  if (isString(numOrStr)) {
    console.log(numOrStr.length)
  }
}
```

看着没有任何问题的代码，但是 Ts 并不能准确推断出正确类型。

这个时候就该使用 `is` 关键字了：

```ts
export const isString = (arg: unknown): arg is string => typeof arg === 'string'
```

这只是以原始类型为成员的联合类型，我们完全可以扩展到各种场景上，先看一个简单的假值判断：

```ts
export type Falsy = false | '' | 0 | null | undefined

export const isFalsy = (val: unknown): val is Falsy => !val
```

### 字面量类型守卫

字面量类型是 TypeScript 中一种特殊的子类型，可以用来确保变量的值与特定的字符串或数字字面量相匹配。

```ts
type Action = { type: 'INCREMENT' } | { type: 'DECREMENT' }

function performAction(action: Action) {
  // 字面量类型守卫
  switch (action.type) {
    case 'INCREMENT':
      // 做一些递增的操作
      break
    case 'DECREMENT':
      // 做一些递减的操作
      break
  }
}
```

## TypeScript 类型系统中的类型运算

我们知道了 TypeScript 类型系统里有哪些类型，那么可以对这些类型做什么类型运算呢？

### 常量、变量、函数的定义（type）

在 ts 类型编程中，类型是它的一等公民，也就是说我们所有输入输出的结果预期应该都是类型。我们知道 ts 中可以使用 `type` 定义一个类型，即 `type` 我们可以理解为是 ts 类型编程中的定义关键词，等同于 `const`、`let`。

```ts
type people = 'man' | 'woman'
```

除了常量、变量外，`type` 也可以用于定义函数，比如我们上面给出的 `shiftArr` 方法，在这个函数中，它的函数变量我们使用泛型来完成定义，泛型后面的 `extends` 大家可以理解为对这个变量的类型限制，比如 `arr extends unknown[]` 意思就是 arr 至少需要满足 `unknown[]` 的类型。

所以这也就是 `type shiftArr<arr extends unknown[]> = …` 能和 `const shiftArr = (arr: unknown[]) => {}` 对应的原因。

### 泛型（Generics）

> 类型编程中的 " 形参 "

泛型允许我们在定义函数或类时不指定具体的类型，而是使用类型变量（`type variables`）作为占位符。这些类型变量可以在函数或类被实例化时被具体的类型替换。这样，同一个函数或类就可以用于多种不同类型的数据，而不需要为每种数据类型编写重复的代码。

```ts
class Wrapper<T> {
  value: T

  constructor(value: T) {
    this.value = value
  }
}

let wrapper1 = new Wrapper<string>('myString') // 类型为 Wrapper<string>
let wrapper2 = new Wrapper<number>(100) // 类型为 Wrapper<number>
```

在这个例子中，`Wrapper` 类是一个泛型类，它有一个类型参数 `T`。我们可以创建 `Wrapper` 类的实例，用于存储任何类型的数据

### 条件判断（extends）

条件类型让类型具有了判断的能力，它们在类型系统中引入了一种选择机制，允许根据条件定义类型。

条件类型跟 JavaScript 中的三元表达式近乎一样，我们也可以理解为这是 TypeScript 类型编程中的 `if-else`

TypeScript 里的条件判断是 `extends ? :`，叫做条件类型（Conditional Type）比如：

```ts
type res = 1 extends 2 ? true : false // false
```

但是，上面这样的逻辑没啥意义，静态的值自己就能算出结果来，为什么要用代码去判断呢？

所以，类型运算逻辑都是用来做一些动态的类型的运算的，也就是对类型参数的运算。

```ts
type IsString<T> = T extends string ? 'yes' : 'no'

type T1 = IsString<string> // "yes"
type T2 = IsString<number> // "no"
```

在这个例子中，`IsString` 是一个条件类型，它检查 `T` 是否可被赋值给 `string`。如果可以，它的结果类型将是字面量类型 `"yes"`，否则是 `"no"`。

这种类型也叫做 `高级类型`。

**高级类型的特点是传入类型参数，经过一系列类型运算逻辑后，返回新的类型。**

#### 分布式条件类型（Distributive Conditional Types）

**当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型。**

```ts
type ToArray<T> = T extends any ? T[] : never
type StrOrNumArray = ToArray<string | number>
// type StrOrNumArray = string[] | number[]
```

这里，`ToArray` 条件类型检查 `T` 是否可被赋值给 `any`，这个总是为真，所以它将 `T` 转换为一个数组 `T[]`。对于 `StrOrNumArray`，由于 `T` 是 `string | number`，`ToArray` 类型将分别应用于 `string` 和 `number`，结果是 `string[] | number[]`。

条件类型在 TypeScript 的类型定义中**非常有用**，尤其是在创建通用的工具类型或者处理库的类型定义时。例如，TypeScript 标准库中就包含了很多内置的条件类型，如 `Exclude`, `Extract`, `ReturnType`, `InstanceType` 等。

条件类型可以用于创建复杂的类型推断，类型转换，以及根据输入类型动态选择输出类型的类型。这也是 TypeScript 类型编程中非常核心的功能之一。

例如: Snakecase to Camelcase

```ts
type Camelcase<Str extends string> =
  Str extends `${infer Left}_${infer Right}${infer Rest}`
    ? `${Left}${Uppercase<Right>}${Camelcase<Rest>}`
    : Str

type T = Camelcase<'aa_aa_aa'>
// type T = "aaAaAa"
```

### 类型提取（infer）

`infer` 关键字是在条件类型中使用的，它允许你在条件的真分支中声明一个类型变量，然后可以在该分支中使用这个类型。说白了就是 `infer` 关键词只能用于 **`extends` 右侧**，即需要联动来使用。

> ts 4.7 新推出的 infer extends 可以指定推导出的类型

#### 从函数类型中提取返回类型

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never
```

在这个 `ReturnType` 类型定义中，`T` 是一个泛型参数，它被期望是一个函数类型。这个条件类型检查 `T` 是否可以赋值给 `(…args: any[]) => infer R` 这样的函数类型。如果可以，TypeScript 将会推断这个函数的返回类型，并将其捕获到 `R` 中。然后 `ReturnType` 就会被解析为 `R`，否则解析为 `any`。

#### 从 Promise 中提取解决的类型

```ts
type UnpackPromise<T> = T extends Promise<infer U> ? U : T
```

#### 从数组类型中提取元素类型

```ts
type ElementType<T> = T extends (infer U)[] ? U : T
```

在这个例子中，`ElementType` 类型检查 `T` 是否是一个数组类型。如果是，它使用 `infer U` 来捕获数组的元素类型，然后将 `ElementType` 解析为该元素类型。如果 `T` 不是数组类型，那么结果类型就是 `T` 自己。

#### 提取元组类型的第一个元素

```ts
type First<Tuple extends unknown[]> = Tuple extends [infer T, ...infer R] ? T : never

type res = First<[1, 2, 3]> // 1
```

注意，第一个 `extends` 不是条件，条件类型是 `extends ? :`，这里的 `extends` 是约束的意思，也就是约束类型参数只能是数组类型。

因为不知道数组元素的具体类型，所以用 `unknown`。

### 映射类型（keyof、in、as）

在 TypeScript 中对象、class 对应的类型是索引类型（`Index Type`），映射类型可以用于修改索引类型，也就是将一个集合映射到另一个集合中。

索引类型查询使用 `keyof` 关键字来获取一个类型的所有属性键组成的联合类型。例如：

```ts
interface Person {
  name: string
  age: number
}

type PersonKeys = keyof Person // 'name' | 'age'
```

映射类型（`Mapped Types`）是一种泛型类型，它能够根据旧的类型创建新的类型——它“映射”过一个已有的类型的属性，生成另一个类型。

映射类型通常与索引签名的语法结合使用，允许你指定一个属性键的集合并为这些键指定值的类型。基本的映射类型看起来像这样：

```ts
type Keys = 'option1' | 'option2'
type Flags = { [K in Keys]: boolean }
// type Flags = {
//   option1: boolean
//   option2: boolean
// }
```

`Keys` 是包含 `'option1'` 和 `'option2'` 的联合类型。`Flags` 是一个映射类型，它创建了一个新的类型，该类型有两个属性：`option1` 和 `option2`，它们的值类型都是 `boolean`。

映射类型的基本语法也就是这样：`{ [P in K]: T }`

- `P` 是我们要遍历的属性名。
- `K` 是属性名的集合，通常是字符串字面量的联合类型或 `string/number/symbol` 类型的子类型。
- `T` 是属性的类型。

所以他天然适合跟索引类型一起使用：

```ts
interface Person {
  name: string
  age: number
}

// Readonly 映射类型，使所有属性变为只读
type ReadonlyPerson = { readonly [P in keyof Person]: Person[P] }

// Partial 映射类型，使所有属性变为可选
type PartialPerson = { [P in keyof Person]?: Person[P] }

// Record 映射类型，创建一个对象类型，其属性键来自 K，属性值类型为 T
type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string>
```

> 如上例子记住核心字段：`in`、`keyof`，在 TypeScript 类型编程中，非常普遍。

#### 映射修饰符

映射类型还支持以下修饰符：

- `readonly` 使属性变为只读。
- `?` 使属性变为可选。
- `-readonly` 移除只读属性。
- `-?` 移除可选属性。

#### 模板字面量类型

模板字面量类型（Template Literal Types）是 TypeScript4.1 引入的新的类型。说白了是一种字符串类型的补充，可以构造出几乎无限多的字符串类型，这使得你能够更精确地描述字符串的形状和模式。

模板字面量类型使用反引号（\`）来定义，就像 JavaScript 中的模板字符串一样。类型中可以包含字符串文字部分和插值部分，插值部分通过 `${}` 包裹一个类型。

```ts
type World = 'world'
type Greeting = `hello ${World}`
```

还可以结合联合类型使用

```ts
type EmailLocaleIDs = `welcome_email_${'en' | 'es' | 'fr'}`
// type EmailLocaleIDs = "welcome_email_en" | "welcome_email_es" | "welcome_email_fr"
type FooterLocaleIDs = `footer_${'en' | 'es' | 'fr'}`
// type FooterLocaleIDs = "footer_en" | "footer_es" | "footer_fr"

type LocaleMessageIDs = `${'welcome_email' | 'footer'}_${'en' | 'es' | 'fr'}`
// type LocaleMessageIDs = "welcome_email_en" | "welcome_email_es" | "welcome_email_fr" | "footer_en" | "footer_es" | "footer_fr"
```

#### 键值重映射

除了值可以变化，索引也可以做变化，用 `as` 运算符，叫做 `重映射`。

在 TypeScript 4.1 及以后版本中，可以使用映射类型中的 `as` 重新映射映射类型中的键：

```ts
type MappedTypeWithNewProperties<Type> = {
  [Properties in keyof Type as NewKeyType]: Type[Properties]
}
```

你可以利用模板字面量类型等功能，从旧的属性名称创建新的属性名称：

```ts
type Getters<Type> = {
  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]
}

interface Person {
  name: string
  age: number
  location: string
}

type LazyPerson = Getters<Person>
// type LazyPerson = {
//   getName: () => string
//   getAge: () => number
//   getLocation: () => string
// }
```

你可以通过条件类型生成 `never` 来过滤掉键

```ts
// Remove the 'kind' property
type RemoveKindField<Type> = {
  [Property in keyof Type as Property extends 'kind' ? never : Property]: Type[Property]
}

interface Circle {
  kind: 'circle'
  radius: number
}

type KindlessCircle = RemoveKindField<Circle>
// type KindlessCircle = {
//   radius: number
// }
```

你可以映射任何联合类型，不仅仅是 `string | number | symbol` 的联合类型

```ts
type EventConfig<Events extends { kind: string }> = {
  [E in Events as E['kind']]: (event: E) => void
}

type SquareEvent = { kind: 'square'; x: number; y: number }
type CircleEvent = { kind: 'circle'; radius: number }

type Config = EventConfig<SquareEvent | CircleEvent>
// type Config = {
//   square: (event: SquareEvent) => void
//   circle: (event: CircleEvent) => void
// }
```

## TypeScript 内置高级类型（截止 TS 5.5）

[Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

### Awaited

取 `Promise` 的 `ValuType` 的高级类型，这个比较常用，ts 也给内置了，就是 `Awaited`。

```ts
type Awaited<T> = T extends null | undefined
  ? T
  : T extends object & { then(onfulfilled: infer F): any }
  ? F extends (value: infer V, ...args: any) => any
    ? Awaited<V>
    : never
  : T
```

类型参数 `T` 是待处理的类型。

如果 `T` 是 `null` 或者 `undefined`，就返回 `T`。

如果 `T` 是对象并且有 `then` 方法，那就提取 `then` 的参数，也就是 `onfulfilled` 函数的类型到 `infer` 声明的局部变量 `F`。

继续提取 `onfullfilled` 函数类型的第一个参数的类型，也就是 `Promise` 返回的值的类型到 `infer` 声明的局部变量 `V`。

递归的处理提取出来的 `V`，直到不再满足上面的条件。

这样就实现了取出嵌套 Promise 的值的类型的目的:

```ts
type AwaitedRes = Awaited<Promise<Promise<Promise<Promise<number>>>>> // number
```

为什么要提取 `then` 方法的第一个参数的返回值类型看下 Promise 的结构就明白了：

```ts
new Promise(() => {
  // xxx
}).then(value => {})
```

`then` 第一个参数是 `onfullfilled` 的回调，从它的第一个参数就能拿到返回的值的类型。

内置的高级类型不再限制必须是 Promise，而是只要对象且有 `then` 方法就可以，这样更通用了一些。

### Partial

索引类型可以通过映射类型的语法做修改，比如把索引变为可选。

```ts
type Partial<T> = {
  [P in keyof T]?: T[P]
}
```

类型参数 `T` 为待处理的类型。

通过映射类型的语法构造一个新的索引类型返回，索引 `P` 是来源于之前的 T 类型的索引，也就是 P in keyof T，索引值的类型也是之前的，也就是 `T[P]`。

这样就实现了把索引类型的索引变为可选的效果：

```ts
type Person = {
  name: 'tony'
  age: 15
}

type PartialRes = Partial<Person>
// {
//   name?: "tony" | undefined;
//   age?: 15 | undefined;
// }
```

### Required

可以把索引变为可选，也同样可以去掉可选，也就是 `Required` 类型：

```ts
type Required<T> = {
  [P in keyof T]-?: T[P]
}
```

类型参数 `T` 为待处理的类型。

通过映射类型的语法构造一个新的索引类型，索引取自之前的索引，也就是 `P in keyof T`，但是要去掉可选，也就是 `-?`，值的类型也是之前的，就是 `T[P]`。

这样就实现了去掉可选修饰的目的：

```ts
type Person = {
  name?: 'tony'
  age?: 15
}

type RequiredRes = Required<Person>
// {
//   name: "tony";
//   age: 15;
// }
```

### Readonly

同样的方式，也可以添加 `readonly` 的修饰：

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}
```

类型参数 `T` 为待处理的类型。

通过映射类型的语法构造一个新的索引类型返回，索引和值的类型都是之前的，也就是 `P in keyof T` 和 `T[P]`，但是要加上 `readonly` 的修饰。

这样就实现了加上 `readonly` 的目的：

```ts
type Person = {
  name: 'tony'
  age: 15
}

type ReadonlyRes = Readonly<Person>
// {
//   readonly name: "tony";
//   readonly age: 15;
// }
```

### Record

`Record` 用于创建索引类型，传入 key 和值的类型：

```ts
type Record<K extends keyof any, T> = {
  [P in K]: T
}
```

这里很巧妙的用到了 `keyof any`，它的结果是 `string | number | symbol`：

但如果你开启了 `keyOfStringsOnly` 的编译选项，它就只是 `string` 了：

用 `keyof any` 是动态获取的，比直接写死 `string | number | symbol` 更好。

继续讲 `Record` 这个类型，它用映射类型的语法创建了新的索引类型，索引来自 `K`，也就是 `P in K`，值是传入的 `T`。

这样就用 `K` 和 `T` 构造出了对应的索引类型。

```ts
type RecordRes = Record<'a' | 'b', number>
// {
//   a: number;
//   b: number;
// }
```

当传入的 `K` 是 `string | number | symbol`，那么创建的就是有可索引签名的索引类型：

```ts
type RecordRes = Record<string, number>
// {
//   [x: string]: number;
// }
```

### Pick

映射类型的语法用于构造新的索引类型，在构造的过程中可以对索引和值做一些修改或过滤。

比如可以用 `Pick` 实现过滤：

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

类型参数 `T` 为待处理的类型，类型参数 `K` 为要过滤出的索引，通过 `extends` 约束为只能是 `T` 的索引的子集。

构造新的索引类型返回，索引取自 `K`，也就是 `P in K`，值则是它对应的原来的值，也就是 `T[P]`。

这样就实现了过滤的目的：

```ts
type Person = {
  name: 'tony'
  age: 15
}

type PickRes = Pick<Person, 'age'>
// {
//   age: 15;
// }
```

### Omit

我们知道了 `Pick` 可以取出索引类型的一部分索引构造成新的索引类型，那反过来就是去掉这部分索引构造成新的索引类型。

可以结合 `Exclude` 来轻松实现：

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

类型参数 `T` 为待处理的类型，类型参数 `K` 为索引允许的类型（`string` | `number` | `symbol` 或者 `string`）。

通过 `Pick` 取出一部分索引构造成新的索引类型，这里用 `Exclude` 把 `K` 对应的索引去掉，把剩下的索引保留。

这样就实现了删除一部分索引的目的：

```ts
type Person = {
  name: 'tony'
  age: 15
}

type OmitRes = Omit<Person, 'age'>
// {
//   name: 'tony';
// }
```

### Exclude

当想从一个联合类型中去掉一部分类型时，可以用 `Exclude` 类型：

```ts
type Exclude<T, U> = T extends U ? never : T
```

联合类型当作为类型参数出现在条件类型左边时，会被分散成单个类型传入，这叫做分布式条件类型。

所以写法上可以简化，`T extends U` 就是对每个类型的判断。

过滤掉 `U` 类型，剩下的类型组成联合类型。也就是取差集。

```ts
type ExcludeRes = Exclude<'a' | 'b' | 'c' | 'd', 'a' | 'b'> // "c" | "d"
```

这里用了分布式条件类型的性质，写法上可以简化。

### Extract

可以过滤掉，自然也可以保留，`Exclude` 反过来就是 `Extract`，也就是取交集：

```ts
type Extract<T, U> = T extends U ? T : never
```

```ts
type ExtractRes = Extract<'a' | 'b' | 'c' | 'd', 'a' | 'b'> // "a" | "b"
```

### NonNullable

`NonNullable` 就是用于判断是否为非空类型（可以去除联合类型中的 `null` 或 `undefined`），也就是不是 `null` 或者 `undefined` 的类型的，实现比较简单：

```ts
type NonNullable<T> = T extends null | undefined ? never : T
```

当传入 `null` 时：

```ts
type NonNullableRes = NonNullable<undefined> // never
```

当传入非空类型时：

```ts
type NonNullableRes = NonNullable<'1' | null> // '1'
```

### Parameters

`Parameters` 用于提取函数类型的参数类型。

源码是这样的：

```ts
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any
  ? P
  : never
```

类型参数 `T` 为待处理的类型，通过 `extends` 约束为函数，参数和返回值任意。

通过 `extends` 匹配一个模式类型，提取参数的类型到 `infer` 声明的局部变量 `P` 中返回。

这样就实现了函数参数类型的提取：

```ts
type ParametersRes = Parameters<(name: string, age: number) => {}> // [name: string, age: number]
```

### ConstructorParameters

构造器类型和函数类型的区别就是可以被 `new`。

`Parameters` 用于提取函数参数的类型，而 `ConstructorParameters` 用于提取构造器参数的类型。

源码是这样的：

```ts
type ConstructorParameters<T extends abstract new (...args: any) => any> =
  T extends abstract new (...args: infer P) => any ? P : never
```

类型参数 `T` 是待处理的类型，通过 `extends` 约束为构造器类型，加个 `abstract` 代表不能直接被实例化（其实不加也行）。

用 `T` 匹配一个模式类型，提取参数的部分到 `infer` 声明的局部变量 `P` 里，返回 `P`。

这样就实现了构造器参数类型的提取：

```ts
interface Person {
  name: string
}

interface PersonConstructor {
  new (name: string): Person
}

type ConstructorParametersRes = ConstructorParameters<PersonConstructor> // [name: string]
```

构造器参数的提取依然是模式匹配。

### ReturnType

`ReturnType` 用于提取函数类型的返回值类型。

源码是这样的：

```ts
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R
  ? R
  : any
```

类型参数 `T` 为待处理的类型，通过 `extends` 约束为函数类型，参数和返回值任意。

用 `T` 匹配一个模式类型，提取返回值的类型到 `infer` 声明的局部变量 `R` 里返回。

这样就实现了函数返回值类型的提取：

```ts
type ReturnTypeRes = ReturnType<() => 'type'> // type
```

和提取函数参数类型差不多，也是个简单的模式匹配。

### InstanceType

提取了构造器参数的类型，自然也可以提取构造器返回值的类型，就是 `InstanceType`。

源码是这样的：

```ts
type InstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (
  ...args: any
) => infer R
  ? R
  : any
```

整体和 `ConstructorParameters` 差不多，只不过提取的不再是参数了，而是返回值。

通过模式匹配提取返回值的类型到 `infer` 声明的局部变量 `R` 里返回。

这样就实现了构造器的实例类型的提取：

```ts
interface Person {
  name: string
}

interface PersonConstructor {
  new (name: string): Person
}

type InstanceTypeRes = InstanceType<PersonConstructor> // Person
```

### NoInfer

调用泛型函数时，TS 能够根据我们传入的任意实参推断类型参数。

```ts
function doSomething<T>(arg: T) {}

// 我们可以明示 T 应该是 string 类型
doSomething<string>('hello!')
// 我们也可以让 T 的类型被自动推断出来
doSomething('hello!')
```

虽然但是，一个难题在于，并不总是清楚要推断的“最佳”类型是什么。这可能会导致 TS 拒绝有效的调用、接受有问题的调用，或者在捕获错误时只报告更糟糕的错误消息。

举个栗子，假设有一个 `createStreetLight` 红绿灯函数，它接受颜色名称列表以及可选的默认颜色。

```ts
function createStreetLight<C extends string>(colors: C[], defaultColor?: C) {}

createStreetLight(['red', 'yellow', 'green'], 'red')
```

当我们传入原始 `colors` 数组中没有的 `defaultColor` 时会发生什么？在此函数中，`colors` 应该是“单一数据源”（source of truth），并说明可以传递给 `defaultColor` 的默认颜色值。

```ts
// 夭寿啦！红绿灯默认是蓝色？
// 这简直无语子，但 TS 居然允许这种操作！
createStreetLight(['red', 'yellow', 'green'], 'blue')
```

在此调用中，类型推断确定 `'blue'` 与 `'red' | 'yellow' | 'green'` 一样有效。因此，TS 不会拒绝调用，而是将泛型 `C` 的类型推断为 `'red' | 'yellow' | 'green' | 'blue'`。

我们目前处理此问题的方案之一是，添加一个受现有类型参数限制的单独类型参数。

```ts
function createStreetLight<C extends string, D extends C>(
  colors: C[],
  defaultColor?: D
) {}

createStreetLight(['red', 'yellow', 'green'], 'blue')
// 报错！
// 'blue' 的参数类型无法赋值给 "red" | "yellow" | "green" | undefined 类型
```

这行之有效，但有点蠢，因为 `D` 可能不会在 `createStreetLight` 函数签名的其他地方复用。虽然在这种场景下差强人意，但在函数签名中有且仅有使用一次的类型参数通常会产生“代码屎山”。

这就是 TS 5.4 引入新型的 `NoInfer<T>` 工具类型的原因。`NoInfer<…>` 中的类型会向 TS 发射电波，告诉 TS 不要深究并匹配内部类型，查找类型推断的候选者。

使用 `NoInfer`，我们可以重构 `createStreetLight`，如下所示：

```ts
function createStreetLight<C extends string>(colors: C[], defaultColor?: NoInfer<C>) {}

createStreetLight(['red', 'yellow', 'green'], 'blue')
// 报错！
// 'blue' 的参数类型无法赋值给 "red" | "yellow" | "green" | undefined 类型
```

将 `defaultColor` 的类型排除在推断的探索之外意味着，`'blue'` 永远不会成为类型推断的候选者，并且类型检查器可以拒绝它。

```ts
// https://github.com/millsp/ts-toolbelt/blob/master/sources/Function/NoInfer.ts
type NoInfer<A extends any> = [A][A extends any ? 0 : never]
```

### ThisParameterType

函数里可以调用 `this`，这个 `this` 的类型也可以约束：

```ts
type Person = {
  name: 'tony'
}

function hello(this: Person) {
  return this.name
}
```

同样，`this` 的类型也可以提取出来，通过 `ThisParameterType` 这个内置的高级类型：

```ts
type Person = {
  name: 'tony'
}

function hello(this: Person) {
  return this.name
}

type ThisParameterTypeRes = ThisParameterType<typeof hello> // Person
```

它的源码是这样的：

```ts
type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown
```

类型参数 `T` 为待处理的类型。

用 `T` 匹配一个模式类型，提取 `this` 的类型到 `infer` 声明的局部变量 `U` 里返回。

这样就实现了 `this` 类型的提取。

### OmitThisParameter

提取出 `this` 的类型之后，自然可以构造一个新的，比如删除 `this` 的类型可以用 `OmitThisParameter`。

它的源码是这样的：

```ts
type OmitThisParameter<T> = unknown extends ThisParameterType<T>
  ? T
  : T extends (...args: infer A) => infer R
  ? (...args: A) => R
  : T
```

类型参数 `T` 为待处理的类型。

用 `ThisParameterType` 提取 `T` 的 `this` 类型，如果提取出来的类型是 `unknown` 或者 `any`，那么 `unknown extends ThisParameterType` 就成立，也就是没有指定 `this` 的类型，所以直接返回 `T`。

否则，就通过模式匹配提取参数和返回值的类型到 `infer` 声明的局部变量 `A` 和 `R` 中，用它们构造新的函数类型返回。

这样，就实现了去掉 `this` 类型的目的：

```ts
type Person = {
  name: 'tony'
}

function hello(this: Person, age: number) {
  return this.name + age
}

type OmitThisParameterRes = OmitThisParameter<typeof hello> // (age: number) => string
```

这个类型除了模式匹配做提取外，也用到了重新构造做变换，稍微复杂一些。

### ThisType

`ThisType` 的作用是可以在对象字面量中指定 `this` 的类型。`ThisType` 不返回转换后的类型，而是通过 `ThisType` 的泛型参数指定 `this` 的类型，下面看一个具体的示例：

> 注意：如果你想使用这个工具类型，那么需要开启 `noImplicitThis` 的 TypeScript 配置。

<iframe src="https://www.typescriptlang.org/play?#code/C4TwDgpgBA8gRgKwgY2AEQgZ2QJwJZjAD2OAPGgDRQCyAfFALxQDeAUFFACYCGw3A-AC4oaANzsoAWwjAAFkU6YhNKADIoAFVl5MG8BHJqatUVAD0ZqTPmKogWjkocnVEAhboG8fQNHqgejMRR6qwBfcVYAMwBXADtUPCIIqW4Aawh4JFRyKjoACk4sZGEUlHRc-EISdOMASmE0PxYJABsZLl5uYSJEQsYuXIA6Hj4oAB9BliCGpuk5BUw2jtQunOweyZtMIZHmMY4cGTCcOOYoHuP+7ipj5etpqACobjWa9WpxANZWZFjMYCh2hC7JRLJObATJsDinYSHAAewgADFQQHCbhQJCtppCJBxJEQAG4QABCIGyMKgETCkjgEBwVE4iNJ5MpOAqdQ4rMc2kwPShUAA1ExOFDTBZ2c4GPRHjRMaynJyQLz+SAhZYZYxxX4pQEURxNYEKsFflyugBGWHiA1ypgAJlNrAN2LxhMyAFYqE69UA"
  border="0"
  frameborder="0"
  height="650"
  width="100%"></iframe>

在上述示例子中，methods 属性的 `this` 类型为 `D & M`，在上下文中指代 `{ x: number, y: number } & { moveBy(dx: number, dy: number): void }`。

`ThisType` 工具类型只是提供了一个空的泛型接口，仅可以在对象字面量上下文中被 TypeScript 识别，如下所示：

```ts
interface ThisType<T> {}
```

也就是说该类型的作用相当于任意空接口。

这基本就是全部的内置高级类型了。

### Uppercase、Lowercase、Capitalize、Uncapitalize

这四个类型是分别实现大写、小写、首字母大写、去掉首字母大写的。

```ts
type UppercaseRes = Uppercase<'aaaa'> // 'AAAA'

type LowercaseRes = Lowercase<'AAAA'> // 'aaaa'

type CapitalizeRes = Capitalize<'aaaa'> // 'Aaaa'

type UncapitalizeRes = Uncapitalize<'AAAA'> // 'aAAA'
```

它们的源码时这样的：

```ts
type Uppercase<S extends string> = intrinsic

type Lowercase<S extends string> = intrinsic

type Capitalize<S extends string> = intrinsic

type Uncapitalize<S extends string> = intrinsic
```

啥情况，`intrinsic` 是啥？

这个 `intrinsic` 是固有的意思，就像 js 里面的有的方法打印会显示 `[native code]` 一样。这部分类型不是在 ts 里实现的，而是编译过程中由 js 实现的。

我们可以在源码里找到对应的处理代码：

![](_attachment/img/aon3g-tuzo2.png)

其实就是 ts 编译器处理到这几个类型时就直接用 js 给算出来了。

为啥要这样做呢？

因为快啊，解析类型是要处理 AST 的，性能比较差，用 js 直接给算出来那多快呀。

## 网址

[type-challenges](https://github.com/type-challenges/type-challenges)

[typescript-exercises](https://typescript-exercises.github.io/)

[type-hero](https://typehero.dev/explore)

[ts-toolbelt](https://github.com/millsp/ts-toolbelt)

```shell
// https://github.com/ln0y/type-challenges-downloader

npx type-challenges-downloader -p ./type-challenges -w 100
```
